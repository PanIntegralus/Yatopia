From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PhantomGaming27249 <jackjstark@gmail.com>
Date: Sun, 30 Aug 2020 17:27:03 -0700
Subject: [PATCH] Basis for Sponge noise generation and dependencies

All classes and methods along with dependencies updated locally

diff --git a/src/main/java/net/yatopia/server/LatticeOrientation.java b/src/main/java/net/yatopia/server/LatticeOrientation.java
new file mode 100644
index 0000000000000000000000000000000000000000..82145a9980b9b6890a0d00f8b79abe5f9fa5e7d8
--- /dev/null
+++ b/src/main/java/net/yatopia/server/LatticeOrientation.java
@@ -0,0 +1,55 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server;
+public enum LatticeOrientation {
+    /**
+     * Generates the simplex-style coherent noise with the classic lattice orientation. Might be better for texturing 3D models, but less good for generating terrain
+     * which has a vertical direction that works differently than the two horizontal directions. There may be subtle diagonal artifacts, similar to classic Simplex.
+     */
+    CLASSIC,
+    /**
+     * Generates simplex-style noise with Y pointing up the main diagonal on the noise lattice. If used properly, this can produce better results than CLASSIC,
+     * when generating 3D worlds with vertical direction that works differently than the two horizontal directions. See the following recommended usage patterns:
+     * - If Y is vertical and X/Z are horizontal, call noise(x, Y, z)
+     * - If Z is vertical and X/Y are horizontal, call noise(x, Z, y) or use mode XY_BEFORE_Z
+     * - If T is time and X/Y or X/Z are horizontal, call noise(x, T, y) or noise(x, T, z), or use mode XY_BEFORE_Z
+     * - If only two coordinates are needed for a 2D noise plane, call noise(x, 0, y) or noise(x, 0, z), or use mode XY_BEFORE_Z
+     */
+    XZ_BEFORE_Y,
+    /**
+     * Generates simplex-style noise with Z pointing up the main diagonal on the noise lattice. If used properly, this can produce better results than CLASSIC,
+     * when generating 3D worlds with vertical direction that works differently than the two horizontal directions. See the following recommended usage patterns:
+     * - If Y is vertical and X/Z are horizontal, call noise(x, z, Y) or use mode XZ_BEFORE_Y
+     * - If Z is vertical and X/Y are horizontal, call noise(x, y, Z)
+     * - If T is time and X/Y or X/Z are horizontal, call noise(x, y, T) or noise(x, z, T), or use mode XY_BEFORE_Z
+     * - If only two coordinates are needed for a 2D noise plane, call noise(x, y, 0) or noise(x, z, 0), or use mode XZ_BEFORE_Y
+     */
+    XY_BEFORE_Z
+}
diff --git a/src/main/java/net/yatopia/server/Noise.java b/src/main/java/net/yatopia/server/Noise.java
new file mode 100644
index 0000000000000000000000000000000000000000..212adb91ce0a97bdbff14444bdb57b02506ada64
--- /dev/null
+++ b/src/main/java/net/yatopia/server/Noise.java
@@ -0,0 +1,341 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server;
+import org.spongepowered.noise.*;
+
+public final class Noise {
+    private static final int X_NOISE_GEN = 1619;
+    private static final int Y_NOISE_GEN = 31337;
+    private static final int Z_NOISE_GEN = 6971;
+    private static final int SEED_NOISE_GEN = 1013;
+    private static final int SHIFT_NOISE_GEN = 8;
+
+    private Noise() {
+    }
+
+    /**
+     * Generates a simplex-style gradient coherent noise value from the coordinates of a three-dimensional input value.
+     * Does not use the classic Simplex noise algorithm, but an alternative. Adapted from the following URLs:
+     * https://github.com/KdotJPG/New-Simplex-Style-Gradient-Noise/blob/master/java/FastSimplexStyleNoise.java
+     * https://github.com/KdotJPG/New-Simplex-Style-Gradient-Noise/blob/master/java/SuperSimplexNoise.java
+     *
+     * @param x The @a x coordinate of the input value.
+     * @param y The @a y coordinate of the input value.
+     * @param z The @a z coordinate of the input value.
+     * @param seed The random number seed.
+     * @param orientation The lattice orientation of the simplex-style coherent noise. See documentation for {@link LatticeOrientation}.
+     * @param quality The quality of the simplex-style coherent noise.
+     * @return The generated gradient-coherent-noise value.
+     * <p/>
+     * The return value ranges from 0 to 1.
+     * <p/>
+     */
+    public static double simplexStyleGradientCoherentNoise3D(double x, double y, double z, int seed, LatticeOrientation orientation, NoiseQualitySimplex quality) {
+        double squaredRadius = quality.getKernelSquaredRadius();
+        double[] randomVectors = quality.getRandomVectors();
+        Utils.LatticePointBCC[] lookup = quality.getLookup();
+
+        // Re-orient the cubic lattices via rotation. These are orthonormal rotations, not skew transforms.
+        double xr, yr, zr;
+        if (orientation == LatticeOrientation.CLASSIC) {
+            double r = (2.0 / 3.0) * (x + y + z);
+            xr = r - x; yr = r - y; zr = r - z;
+        } else if (orientation == LatticeOrientation.XY_BEFORE_Z) {
+            double xy = x + y;
+            double s2 = xy * -0.211324865405187;
+            double zz = z * 0.577350269189626;
+            xr = x + s2 - zz; yr = y + s2 - zz;
+            zr = xy * 0.577350269189626 + zz;
+        } else { // XZ_BEFORE_Y
+            double xz = x + z;
+            double s2 = xz * -0.211324865405187;
+            double yy = y * 0.577350269189626;
+            xr = x + s2 - yy; zr = z + s2 - yy;
+            yr = xz * 0.577350269189626 + yy;
+        }
+
+        // Get base and offsets inside cube of first lattice.
+        int xrb = ((xr > 0.0) ? (int) xr : (int) xr - 1);
+        int yrb = ((yr > 0.0) ? (int) yr : (int) yr - 1);
+        int zrb = ((zr > 0.0) ? (int) zr : (int) zr - 1);
+        double xri = xr - xrb, yri = yr - yrb, zri = zr - zrb;
+
+        // Identify which octant of the cube we're in. This determines which cell
+        // in the other cubic lattice we're in, and also narrows down one point on each.
+        int xht = (int)(xri + 0.5), yht = (int)(yri + 0.5), zht = (int)(zri + 0.5);
+        int index = (xht << 0) | (yht << 1) | (zht << 2);
+
+        // Point contributions
+        double value = 0.5;
+        Utils.LatticePointBCC c = lookup[index];
+        do {
+            double dxr = xri + c.dxr, dyr = yri + c.dyr, dzr = zri + c.dzr;
+            double attn = squaredRadius - dxr * dxr - dyr * dyr - dzr * dzr;
+            if (attn < 0) {
+                c = c.nextOnFailure;
+            } else {
+                int ix = xrb + c.xrv, iy = yrb + c.yrv, iz = zrb + c.zrv;
+                int vectorIndex = (X_NOISE_GEN * ix + Y_NOISE_GEN * iy + Z_NOISE_GEN * iz + SEED_NOISE_GEN * seed);
+                vectorIndex ^= (vectorIndex >> SHIFT_NOISE_GEN);
+                vectorIndex &= 0xff;
+                double xvGradient = randomVectors[(vectorIndex << 2)];
+                double yvGradient = randomVectors[(vectorIndex << 2) + 1];
+                double zvGradient = randomVectors[(vectorIndex << 2) + 2];
+                double ramped = ((xvGradient * dxr) + (yvGradient * dyr) + (zvGradient * dzr));
+
+                attn *= attn;
+                value += attn * attn * ramped;
+                c = c.nextOnSuccess;
+            }
+        } while (c != null);
+        return value;
+    }
+
+    /**
+     * Generates a gradient-coherent-noise value from the coordinates of a three-dimensional input value.
+     *
+     * @param x The @a x coordinate of the input value.
+     * @param y The @a y coordinate of the input value.
+     * @param z The @a z coordinate of the input value.
+     * @param seed The random number seed.
+     * @param quality The quality of the coherent-noise.
+     * @return The generated gradient-coherent-noise value.
+     * <p/>
+     * The return value ranges from 0 to 1.
+     * <p/>
+     * For an explanation of the difference between <i>gradient</i> noise and <i>value</i> noise, see the comments for the GradientNoise3D() function.
+     */
+    public static double gradientCoherentNoise3D(double x, double y, double z, int seed, NoiseQuality quality) {
+
+        // Create a unit-length cube aligned along an integer boundary.  This cube
+        // surrounds the input point.
+
+        int x0 = ((x > 0.0) ? (int) x : (int) x - 1);
+        int x1 = x0 + 1;
+
+        int y0 = ((y > 0.0) ? (int) y : (int) y - 1);
+        int y1 = y0 + 1;
+
+        int z0 = ((z > 0.0) ? (int) z : (int) z - 1);
+        int z1 = z0 + 1;
+
+        // Map the difference between the coordinates of the input value and the
+        // coordinates of the cube's outer-lower-left vertex onto an S-curve.
+        double xs, ys, zs;
+        if (quality == NoiseQuality.FAST) {
+            xs = (x - (double) x0);
+            ys = (y - (double) y0);
+            zs = (z - (double) z0);
+        } else if (quality == NoiseQuality.STANDARD) {
+            xs = Utils.sCurve3(x - (double) x0);
+            ys = Utils.sCurve3(y - (double) y0);
+            zs = Utils.sCurve3(z - (double) z0);
+        } else {
+
+            xs = Utils.sCurve5(x - (double) x0);
+            ys = Utils.sCurve5(y - (double) y0);
+            zs = Utils.sCurve5(z - (double) z0);
+        }
+
+        // Now calculate the noise values at each vertex of the cube.  To generate
+        // the coherent-noise value at the input point, interpolate these eight
+        // noise values using the S-curve value as the interpolant (trilinear
+        // interpolation.)
+        double n0, n1, ix0, ix1, iy0, iy1;
+        n0 = gradientNoise3D(x, y, z, x0, y0, z0, seed);
+        n1 = gradientNoise3D(x, y, z, x1, y0, z0, seed);
+        ix0 = Utils.linearInterp(n0, n1, xs);
+
+        n0 = gradientNoise3D(x, y, z, x0, y1, z0, seed);
+        n1 = gradientNoise3D(x, y, z, x1, y1, z0, seed);
+        ix1 = Utils.linearInterp(n0, n1, xs);
+        iy0 = Utils.linearInterp(ix0, ix1, ys);
+        n0 = gradientNoise3D(x, y, z, x0, y0, z1, seed);
+        n1 = gradientNoise3D(x, y, z, x1, y0, z1, seed);
+        ix0 = Utils.linearInterp(n0, n1, xs);
+        n0 = gradientNoise3D(x, y, z, x0, y1, z1, seed);
+        n1 = gradientNoise3D(x, y, z, x1, y1, z1, seed);
+        ix1 = Utils.linearInterp(n0, n1, xs);
+        iy1 = Utils.linearInterp(ix0, ix1, ys);
+        return Utils.linearInterp(iy0, iy1, zs);
+    }
+
+    /**
+     * Generates a gradient-noise value from the coordinates of a three-dimensional input value and the integer coordinates of a nearby three-dimensional value.
+     *
+     * @param fx The floating-point @a x coordinate of the input value.
+     * @param fy The floating-point @a y coordinate of the input value.
+     * @param fz The floating-point @a z coordinate of the input value.
+     * @param ix The integer @a x coordinate of a nearby value.
+     * @param iy The integer @a y coordinate of a nearby value.
+     * @param iz The integer @a z coordinate of a nearby value.
+     * @param seed The random number seed.
+     * @return The generated gradient-noise value.
+     * <p/>
+     * The difference between fx and ix must be less than or equal to one. The difference between @a fy and @a iy must be less than or equal to one. The difference between @a fz and @a iz must be less
+     * than or equal to one.
+     * <p/>
+     * A <i>gradient</i>-noise function generates better-quality noise than a <i>value</i>-noise function. Most noise modules use gradient noise for this reason, although it takes much longer to
+     * calculate.
+     * <p/>
+     * The return value ranges from 0 to 1.
+     * <p/>
+     * This function generates a gradient-noise value by performing the following steps: - It first calculates a random normalized vector based on the nearby integer value passed to this function. -
+     * It then calculates a new value by adding this vector to the nearby integer value passed to this function. - It then calculates the dot product of the above-generated value and the
+     * floating-point input value passed to this function.
+     * <p/>
+     * A noise function differs from a random-number generator because it always returns the same output value if the same input value is passed to it.
+     */
+    public static double gradientNoise3D(double fx, double fy, double fz, int ix, int iy, int iz, int seed) {
+        // Randomly generate a gradient vector given the integer coordinates of the
+        // input value.  This implementation generates a random number and uses it
+        // as an index into a normalized-vector lookup table.
+        int vectorIndex = (X_NOISE_GEN * ix + Y_NOISE_GEN * iy + Z_NOISE_GEN * iz + SEED_NOISE_GEN * seed);
+        vectorIndex ^= (vectorIndex >> SHIFT_NOISE_GEN);
+        vectorIndex &= 0xff;
+
+        double xvGradient = Utils.RANDOM_VECTORS_PERLIN[(vectorIndex << 2)];
+        double yvGradient = Utils.RANDOM_VECTORS_PERLIN[(vectorIndex << 2) + 1];
+        double zvGradient = Utils.RANDOM_VECTORS_PERLIN[(vectorIndex << 2) + 2];
+
+        // Set up us another vector equal to the distance between the two vectors
+        // passed to this function.
+        double xvPoint = (fx - ix);
+        double yvPoint = (fy - iy);
+        double zvPoint = (fz - iz);
+
+        // Now compute the dot product of the gradient vector with the distance
+        // vector.  The resulting value is gradient noise.  Apply a scaling and
+        // offset value so that this noise value ranges from 0 to 1.
+        return ((xvGradient * xvPoint) + (yvGradient * yvPoint) + (zvGradient * zvPoint)) + 0.5;
+    }
+
+    /**
+     * Generates an integer-noise value from the coordinates of a three-dimensional input value.
+     *
+     * @param x The integer @a x coordinate of the input value.
+     * @param y The integer @a y coordinate of the input value.
+     * @param z The integer @a z coordinate of the input value.
+     * @param seed A random number seed.
+     * @return The generated integer-noise value.
+     * <p/>
+     * The return value ranges from 0 to 2147483647.
+     * <p/>
+     * A noise function differs from a random-number generator because it always returns the same output value if the same input value is passed to it.
+     */
+    public static int intValueNoise3D(int x, int y, int z, int seed) {
+        // All constants are primes and must remain prime in order for this noise
+        // function to work correctly.
+        int n = (X_NOISE_GEN * x + Y_NOISE_GEN * y + Z_NOISE_GEN * z + SEED_NOISE_GEN * seed) & 0x7fffffff;
+        n = (n >> 13) ^ n;
+        return (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;
+    }
+
+    /**
+     * Generates a value-coherent-noise value from the coordinates of a three-dimensional input value.
+     *
+     * @param x The @a x coordinate of the input value.
+     * @param y The @a y coordinate of the input value.
+     * @param z The @a z coordinate of the input value.
+     * @param seed The random number seed.
+     * @param quality The quality of the coherent-noise.
+     * @return The generated value-coherent-noise value.
+     * <p/>
+     * The return value ranges from 0 to 1.
+     * <p/>
+     * For an explanation of the difference between <i>gradient</i> noise and <i>value</i> noise, see the comments for the GradientNoise3D() function.
+     */
+    public static double valueCoherentNoise3D(double x, double y, double z, int seed, NoiseQuality quality) {
+        // Create a unit-length cube aligned along an integer boundary.  This cube
+        // surrounds the input point.
+        int x0 = (x > 0.0 ? (int) x : (int) x - 1);
+        int x1 = x0 + 1;
+        int y0 = (y > 0.0 ? (int) y : (int) y - 1);
+        int y1 = y0 + 1;
+        int z0 = (z > 0.0 ? (int) z : (int) z - 1);
+        int z1 = z0 + 1;
+
+        // Map the difference between the coordinates of the input value and the
+        // coordinates of the cube's outer-lower-left vertex onto an S-curve.
+        double xs, ys, zs;
+        if (quality == NoiseQuality.FAST) {
+            xs = (x - x0);
+            ys = (y - y0);
+            zs = (z - z0);
+        } else if (quality == NoiseQuality.STANDARD) {
+            xs = Utils.sCurve3(x - x0);
+            ys = Utils.sCurve3(y - y0);
+            zs = Utils.sCurve3(z - z0);
+        } else {
+
+            xs = Utils.sCurve5(x - x0);
+            ys = Utils.sCurve5(y - y0);
+            zs = Utils.sCurve5(z - z0);
+        }
+
+        // Now calculate the noise values at each vertex of the cube.  To generate
+        // the coherent-noise value at the input point, interpolate these eight
+        // noise values using the S-curve value as the interpolant (trilinear
+        // interpolation.)
+        double n0, n1, ix0, ix1, iy0, iy1;
+        n0 = valueNoise3D(x0, y0, z0, seed);
+        n1 = valueNoise3D(x1, y0, z0, seed);
+        ix0 = Utils.linearInterp(n0, n1, xs);
+        n0 = valueNoise3D(x0, y1, z0, seed);
+        n1 = valueNoise3D(x1, y1, z0, seed);
+        ix1 = Utils.linearInterp(n0, n1, xs);
+        iy0 = Utils.linearInterp(ix0, ix1, ys);
+        n0 = valueNoise3D(x0, y0, z1, seed);
+        n1 = valueNoise3D(x1, y0, z1, seed);
+        ix0 = Utils.linearInterp(n0, n1, xs);
+        n0 = valueNoise3D(x0, y1, z1, seed);
+        n1 = valueNoise3D(x1, y1, z1, seed);
+        ix1 = Utils.linearInterp(n0, n1, xs);
+        iy1 = Utils.linearInterp(ix0, ix1, ys);
+        return Utils.linearInterp(iy0, iy1, zs);
+    }
+
+    /**
+     * Generates a value-noise value from the coordinates of a three-dimensional input value.
+     *
+     * @param x The @a x coordinate of the input value.
+     * @param y The @a y coordinate of the input value.
+     * @param z The @a z coordinate of the input value.
+     * @param seed A random number seed.
+     * @return The generated value-noise value.
+     * <p/>
+     * The return value ranges from 0 to 1.
+     * <p/>
+     * A noise function differs from a random-number generator because it always returns the same output value if the same input value is passed to it.
+     */
+    public static double valueNoise3D(int x, int y, int z, int seed) {
+        return intValueNoise3D(x, y, z, seed) / 2147483647.0;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/NoiseQuality.java b/src/main/java/net/yatopia/server/NoiseQuality.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c24e14e0a06866982febeed9b1cf74d6dec1c49
--- /dev/null
+++ b/src/main/java/net/yatopia/server/NoiseQuality.java
@@ -0,0 +1,48 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server;
+
+public enum NoiseQuality {
+    /**
+     * Generates coherent noise quickly.  When a coherent-noise function with this quality setting is used to generate a bump-map image, there are noticeable "creasing" artifacts in the resulting image.
+     * This is because the derivative of that function is discontinuous at integer boundaries.
+     */
+    FAST,
+    /**
+     * Generates standard-quality coherent noise. When a coherent-noise function with this quality setting is used to generate a bump-map image, there are some minor "creasing" artifacts in the resulting
+     * image. This is because the second derivative of that function is discontinuous at integer boundaries.
+     */
+    STANDARD,
+    /**
+     * Generates the best-quality coherent noise. When a coherent-noise function with this quality setting is used to generate a bump-map image, there are no "creasing" artifacts in the resulting image.
+     * This is because the first and second derivatives of that function are continuous at integer boundaries.
+     */
+    BEST
+}
diff --git a/src/main/java/net/yatopia/server/NoiseQualitySimplex.java b/src/main/java/net/yatopia/server/NoiseQualitySimplex.java
new file mode 100644
index 0000000000000000000000000000000000000000..a331e357950be7fcf11b48cc7cbb9c34b1f2124e
--- /dev/null
+++ b/src/main/java/net/yatopia/server/NoiseQualitySimplex.java
@@ -0,0 +1,67 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server;
+
+import org.spongepowered.noise.*;
+
+public enum NoiseQualitySimplex {
+    /**
+     * Generates simplex-style noise using the four nearst lattice vertices and smaller kernels. The appearance might be more bubbly, and there might be more straight line segments in the ridged noise.
+     * However, Ridged noise using this setting may still be more favorable than the Perlin / non-Simplex Ridged noise.
+     */
+    STANDARD(0.5, Utils.RANDOM_VECTORS_SIMPLEXSTYLE_STANDARD, Utils.LOOKUP_SIMPLEXSTYLE_STANDARD),
+
+    /**
+     * Generates simplex-style using the eight nearest lattice vertices and larger kernels. The appearance will be smoother, and there will be fewer to no straight line segments in the ridged noise.
+     */
+    SMOOTH(0.75, Utils.RANDOM_VECTORS_SIMPLEXSTYLE_SMOOTH, Utils.LOOKUP_SIMPLEXSTYLE_SMOOTH);
+
+    private double kernelSquaredRadius;
+    private double[] randomVectors;
+    private Utils.LatticePointBCC[] lookup;
+
+    private NoiseQualitySimplex(double kernelSquaredRadius, double[] randomVectors, Utils.LatticePointBCC[] lookup) {
+        this.kernelSquaredRadius = kernelSquaredRadius;
+        this.randomVectors = randomVectors;
+        this.lookup = lookup;
+    }
+
+    public double getKernelSquaredRadius() {
+        return kernelSquaredRadius;
+    }
+
+    public double[] getRandomVectors() {
+        return randomVectors;
+    }
+
+    public Utils.LatticePointBCC[] getLookup() {
+        return lookup;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/Utils.java b/src/main/java/net/yatopia/server/Utils.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ec7c67682d1018fd487a29d2fc5f22a0a8892e8
--- /dev/null
+++ b/src/main/java/net/yatopia/server/Utils.java
@@ -0,0 +1,371 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server;
+public final class Utils {
+    private Utils() {
+    }
+
+    /**
+     * Performs cubic interpolation between two values bound between two other values
+     *
+     * @param n0 the value before the first value
+     * @param n1 the first value
+     * @param n2 the second value
+     * @param n3 the value after the second value
+     * @param a the alpha value
+     * @return the interpolated value
+     */
+    public static double cubicInterp(double n0, double n1, double n2, double n3, double a) {
+        double p = (n3 - n2) - (n0 - n1);
+        double q = (n0 - n1) - p;
+        double r = n2 - n0;
+
+        return p * a * a * a + q * a * a + r * a + n1;
+    }
+
+    /**
+     * Performs linear interpolation between two values
+     *
+     * @param n0 first value
+     * @param n1 second value
+     * @param a the alpha value. Should be between 0 and 1.
+     * @return the interpolated value
+     */
+    public static double linearInterp(double n0, double n1, double a) {
+        return (1.0 - a) * n0 + (a * n1);
+    }
+
+    /**
+     * Maps a value onto a cubic S-Curve
+     *
+     * @param a the value to map onto a S-Curve
+     * @return the mapped value
+     */
+    public static double sCurve3(double a) {
+        return (a * a * (3.0 - 2.0 * a));
+    }
+
+    /**
+     * maps a value onto a quitnic S-Curve
+     *
+     * @param a the value to map onto a quitic S-curve
+     * @return the mapped value
+     */
+    public static double sCurve5(double a) {
+        double a3 = a * a * a;
+        double a4 = a3 * a;
+        double a5 = a4 * a;
+        return (6.0 * a5) - (15.0 * a4) + (10.0 * a3);
+    }
+
+    public static double[] latLonToXYZ(double latitude, double longitude) {
+        double r = Math.cos(Math.toRadians(latitude));
+        double x = r * Math.cos(Math.toRadians(longitude));
+        double y = Math.sin(Math.toRadians(latitude));
+        double z = r * Math.sin(Math.toRadians(longitude));
+        return new double[]{x, y, z};
+    }
+
+    /**
+     * Modifies a floating-point value so that it can be stored in a noise::int32 variable.
+     *
+     * @param n A floating-point number.
+     * @return The modified floating-point number.
+     * <p/>
+     * This function does not modify @a n.
+     * <p/>
+     * In libnoise, the noise-generating algorithms are all integer-based; they use variables of type noise::int32. Before calling a noise function, pass the @a x, @a y, and @a z coordinates to this
+     * function to ensure that these coordinates can be cast to a noise::int32 value.
+     * <p/>
+     * Although you could do a straight cast from double to noise::int32, the resulting value may differ between platforms. By using this function, you ensure that the resulting value is identical
+     * between platforms.
+     */
+    public static double makeInt32Range(double n) {
+        if (n >= 1073741824.0) {
+            return (2.0 * n % 1073741824.0) - 1073741824.0;
+        } else if (n <= -1073741824.0) {
+            return (2.0 * n % 1073741824.0) + 1073741824.0;
+        } else {
+            return n;
+        }
+    }
+
+    /**
+     * Clamps the value between the low and high boundaries
+     *
+     * @param value The value to clamp
+     * @param low The low bound of the clamp
+     * @param high The high bound of the clamp
+     * @return the clamped value
+     */
+    public static int clamp(int value, int low, int high) {
+        if (value < low) {
+            return low;
+        }
+        if (value > high) {
+            return high;
+        }
+        return value;
+    }
+
+    /**
+     * Rounds x down to the closest integer
+     *
+     * @param x The value to floor
+     * @return The closest integer
+     */
+    public static int floor(double x) {
+        int y = (int) x;
+        if (x < y) {
+            return y - 1;
+        }
+        return y;
+    }
+
+    /**
+     * A table of 256 random normalized vectors. Each row is an (x, y, z, 0) coordinate. The 0 is used as padding so we can use bit shifts to index any row in the table. These vectors have an even
+     * statistical distribution, which improves the quality of the coherent noise generated by these vectors. For more information, see "GPU Gems", Chapter 5 - Implementing Improved Perlin Noise by
+     * Ken Perlin, specifically page 76.
+     */
+    public static final double[] RANDOM_VECTORS = {
+            -0.763874, -0.596439, -0.246489, 0.0, 0.396055, 0.904518, -0.158073, 0.0, -0.499004, -0.8665, -0.0131631, 0.0, 0.468724, -0.824756, 0.316346, 0.0,
+            0.829598, 0.43195, 0.353816, 0.0, -0.454473, 0.629497, -0.630228, 0.0, -0.162349, -0.869962, -0.465628, 0.0, 0.932805, 0.253451, 0.256198, 0.0,
+            -0.345419, 0.927299, -0.144227, 0.0, -0.715026, -0.293698, -0.634413, 0.0, -0.245997, 0.717467, -0.651711, 0.0, -0.967409, -0.250435, -0.037451, 0.0,
+            0.901729, 0.397108, -0.170852, 0.0, 0.892657, -0.0720622, -0.444938, 0.0, 0.0260084, -0.0361701, 0.999007, 0.0, 0.949107, -0.19486, 0.247439, 0.0,
+            0.471803, -0.807064, -0.355036, 0.0, 0.879737, 0.141845, 0.453809, 0.0, 0.570747, 0.696415, 0.435033, 0.0, -0.141751, -0.988233, -0.0574584, 0.0,
+            -0.58219, -0.0303005, 0.812488, 0.0, -0.60922, 0.239482, -0.755975, 0.0, 0.299394, -0.197066, -0.933557, 0.0, -0.851615, -0.220702, -0.47544, 0.0,
+            0.848886, 0.341829, -0.403169, 0.0, -0.156129, -0.687241, 0.709453, 0.0, -0.665651, 0.626724, 0.405124, 0.0, 0.595914, -0.674582, 0.43569, 0.0,
+            0.171025, -0.509292, 0.843428, 0.0, 0.78605, 0.536414, -0.307222, 0.0, 0.18905, -0.791613, 0.581042, 0.0, -0.294916, 0.844994, 0.446105, 0.0,
+            0.342031, -0.58736, -0.7335, 0.0, 0.57155, 0.7869, 0.232635, 0.0, 0.885026, -0.408223, 0.223791, 0.0, -0.789518, 0.571645, 0.223347, 0.0,
+            0.774571, 0.31566, 0.548087, 0.0, -0.79695, -0.0433603, -0.602487, 0.0, -0.142425, -0.473249, -0.869339, 0.0, -0.0698838, 0.170442, 0.982886, 0.0,
+            0.687815, -0.484748, 0.540306, 0.0, 0.543703, -0.534446, -0.647112, 0.0, 0.97186, 0.184391, -0.146588, 0.0, 0.707084, 0.485713, -0.513921, 0.0,
+            0.942302, 0.331945, 0.043348, 0.0, 0.499084, 0.599922, 0.625307, 0.0, -0.289203, 0.211107, 0.9337, 0.0, 0.412433, -0.71667, -0.56239, 0.0,
+            0.87721, -0.082816, 0.47291, 0.0, -0.420685, -0.214278, 0.881538, 0.0, 0.752558, -0.0391579, 0.657361, 0.0, 0.0765725, -0.996789, 0.0234082, 0.0,
+            -0.544312, -0.309435, -0.779727, 0.0, -0.455358, -0.415572, 0.787368, 0.0, -0.874586, 0.483746, 0.0330131, 0.0, 0.245172, -0.0838623, 0.965846, 0.0,
+            0.382293, -0.432813, 0.81641, 0.0, -0.287735, -0.905514, 0.311853, 0.0, -0.667704, 0.704955, -0.239186, 0.0, 0.717885, -0.464002, -0.518983, 0.0,
+            0.976342, -0.214895, 0.0240053, 0.0, -0.0733096, -0.921136, 0.382276, 0.0, -0.986284, 0.151224, -0.0661379, 0.0, -0.899319, -0.429671, 0.0812908, 0.0,
+            0.652102, -0.724625, 0.222893, 0.0, 0.203761, 0.458023, -0.865272, 0.0, -0.030396, 0.698724, -0.714745, 0.0, -0.460232, 0.839138, 0.289887, 0.0,
+            -0.0898602, 0.837894, 0.538386, 0.0, -0.731595, 0.0793784, 0.677102, 0.0, -0.447236, -0.788397, 0.422386, 0.0, 0.186481, 0.645855, -0.740335, 0.0,
+            -0.259006, 0.935463, 0.240467, 0.0, 0.445839, 0.819655, -0.359712, 0.0, 0.349962, 0.755022, -0.554499, 0.0, -0.997078, -0.0359577, 0.0673977, 0.0,
+            -0.431163, -0.147516, -0.890133, 0.0, 0.299648, -0.63914, 0.708316, 0.0, 0.397043, 0.566526, -0.722084, 0.0, -0.502489, 0.438308, -0.745246, 0.0,
+            0.0687235, 0.354097, 0.93268, 0.0, -0.0476651, -0.462597, 0.885286, 0.0, -0.221934, 0.900739, -0.373383, 0.0, -0.956107, -0.225676, 0.186893, 0.0,
+            -0.187627, 0.391487, -0.900852, 0.0, -0.224209, -0.315405, 0.92209, 0.0, -0.730807, -0.537068, 0.421283, 0.0, -0.0353135, -0.816748, 0.575913, 0.0,
+            -0.941391, 0.176991, -0.287153, 0.0, -0.154174, 0.390458, 0.90762, 0.0, -0.283847, 0.533842, 0.796519, 0.0, -0.482737, -0.850448, 0.209052, 0.0,
+            -0.649175, 0.477748, 0.591886, 0.0, 0.885373, -0.405387, -0.227543, 0.0, -0.147261, 0.181623, -0.972279, 0.0, 0.0959236, -0.115847, -0.988624, 0.0,
+            -0.89724, -0.191348, 0.397928, 0.0, 0.903553, -0.428461, -0.00350461, 0.0, 0.849072, -0.295807, -0.437693, 0.0, 0.65551, 0.741754, -0.141804, 0.0,
+            0.61598, -0.178669, 0.767232, 0.0, 0.0112967, 0.932256, -0.361623, 0.0, -0.793031, 0.258012, 0.551845, 0.0, 0.421933, 0.454311, 0.784585, 0.0,
+            -0.319993, 0.0401618, -0.946568, 0.0, -0.81571, 0.551307, -0.175151, 0.0, -0.377644, 0.00322313, 0.925945, 0.0, 0.129759, -0.666581, -0.734052, 0.0,
+            0.601901, -0.654237, -0.457919, 0.0, -0.927463, -0.0343576, -0.372334, 0.0, -0.438663, -0.868301, -0.231578, 0.0, -0.648845, -0.749138, -0.133387, 0.0,
+            0.507393, -0.588294, 0.629653, 0.0, 0.726958, 0.623665, 0.287358, 0.0, 0.411159, 0.367614, -0.834151, 0.0, 0.806333, 0.585117, -0.0864016, 0.0,
+            0.263935, -0.880876, 0.392932, 0.0, 0.421546, -0.201336, 0.884174, 0.0, -0.683198, -0.569557, -0.456996, 0.0, -0.117116, -0.0406654, -0.992285, 0.0,
+            -0.643679, -0.109196, -0.757465, 0.0, -0.561559, -0.62989, 0.536554, 0.0, 0.0628422, 0.104677, -0.992519, 0.0, 0.480759, -0.2867, -0.828658, 0.0,
+            -0.228559, -0.228965, -0.946222, 0.0, -0.10194, -0.65706, -0.746914, 0.0, 0.0689193, -0.678236, 0.731605, 0.0, 0.401019, -0.754026, 0.52022, 0.0,
+            -0.742141, 0.547083, -0.387203, 0.0, -0.00210603, -0.796417, -0.604745, 0.0, 0.296725, -0.409909, -0.862513, 0.0, -0.260932, -0.798201, 0.542945, 0.0,
+            -0.641628, 0.742379, 0.192838, 0.0, -0.186009, -0.101514, 0.97729, 0.0, 0.106711, -0.962067, 0.251079, 0.0, -0.743499, 0.30988, -0.592607, 0.0,
+            -0.795853, -0.605066, -0.0226607, 0.0, -0.828661, -0.419471, -0.370628, 0.0, 0.0847218, -0.489815, -0.8677, 0.0, -0.381405, 0.788019, -0.483276, 0.0,
+            0.282042, -0.953394, 0.107205, 0.0, 0.530774, 0.847413, 0.0130696, 0.0, 0.0515397, 0.922524, 0.382484, 0.0, -0.631467, -0.709046, 0.313852, 0.0,
+            0.688248, 0.517273, 0.508668, 0.0, 0.646689, -0.333782, -0.685845, 0.0, -0.932528, -0.247532, -0.262906, 0.0, 0.630609, 0.68757, -0.359973, 0.0,
+            0.577805, -0.394189, 0.714673, 0.0, -0.887833, -0.437301, -0.14325, 0.0, 0.690982, 0.174003, 0.701617, 0.0, -0.866701, 0.0118182, 0.498689, 0.0,
+            -0.482876, 0.727143, 0.487949, 0.0, -0.577567, 0.682593, -0.447752, 0.0, 0.373768, 0.0982991, 0.922299, 0.0, 0.170744, 0.964243, -0.202687, 0.0,
+            0.993654, -0.035791, -0.106632, 0.0, 0.587065, 0.4143, -0.695493, 0.0, -0.396509, 0.26509, -0.878924, 0.0, -0.0866853, 0.83553, -0.542563, 0.0,
+            0.923193, 0.133398, -0.360443, 0.0, 0.00379108, -0.258618, 0.965972, 0.0, 0.239144, 0.245154, -0.939526, 0.0, 0.758731, -0.555871, 0.33961, 0.0,
+            0.295355, 0.309513, 0.903862, 0.0, 0.0531222, -0.91003, -0.411124, 0.0, 0.270452, 0.0229439, -0.96246, 0.0, 0.563634, 0.0324352, 0.825387, 0.0,
+            0.156326, 0.147392, 0.976646, 0.0, -0.0410141, 0.981824, 0.185309, 0.0, -0.385562, -0.576343, -0.720535, 0.0, 0.388281, 0.904441, 0.176702, 0.0,
+            0.945561, -0.192859, -0.262146, 0.0, 0.844504, 0.520193, 0.127325, 0.0, 0.0330893, 0.999121, -0.0257505, 0.0, -0.592616, -0.482475, -0.644999, 0.0,
+            0.539471, 0.631024, -0.557476, 0.0, 0.655851, -0.027319, -0.754396, 0.0, 0.274465, 0.887659, 0.369772, 0.0, -0.123419, 0.975177, -0.183842, 0.0,
+            -0.223429, 0.708045, 0.66989, 0.0, -0.908654, 0.196302, 0.368528, 0.0, -0.95759, -0.00863708, 0.288005, 0.0, 0.960535, 0.030592, 0.276472, 0.0,
+            -0.413146, 0.907537, 0.0754161, 0.0, -0.847992, 0.350849, -0.397259, 0.0, 0.614736, 0.395841, 0.68221, 0.0, -0.503504, -0.666128, -0.550234, 0.0,
+            -0.268833, -0.738524, -0.618314, 0.0, 0.792737, -0.60001, -0.107502, 0.0, -0.637582, 0.508144, -0.579032, 0.0, 0.750105, 0.282165, -0.598101, 0.0,
+            -0.351199, -0.392294, -0.850155, 0.0, 0.250126, -0.960993, -0.118025, 0.0, -0.732341, 0.680909, -0.0063274, 0.0, -0.760674, -0.141009, 0.633634, 0.0,
+            0.222823, -0.304012, 0.926243, 0.0, 0.209178, 0.505671, 0.836984, 0.0, 0.757914, -0.56629, -0.323857, 0.0, -0.782926, -0.339196, 0.52151, 0.0,
+            -0.462952, 0.585565, 0.665424, 0.0, 0.61879, 0.194119, -0.761194, 0.0, 0.741388, -0.276743, 0.611357, 0.0, 0.707571, 0.702621, 0.0752872, 0.0,
+            0.156562, 0.819977, 0.550569, 0.0, -0.793606, 0.440216, 0.42, 0.0, 0.234547, 0.885309, -0.401517, 0.0, 0.132598, 0.80115, -0.58359, 0.0,
+            -0.377899, -0.639179, 0.669808, 0.0, -0.865993, -0.396465, 0.304748, 0.0, -0.624815, -0.44283, 0.643046, 0.0, -0.485705, 0.825614, -0.287146, 0.0,
+            -0.971788, 0.175535, 0.157529, 0.0, -0.456027, 0.392629, 0.798675, 0.0, -0.0104443, 0.521623, -0.853112, 0.0, -0.660575, -0.74519, 0.091282, 0.0,
+            -0.0157698, -0.307475, -0.951425, 0.0, -0.603467, -0.250192, 0.757121, 0.0, 0.506876, 0.25006, 0.824952, 0.0, 0.255404, 0.966794, 0.00884498, 0.0,
+            0.466764, -0.874228, -0.133625, 0.0, 0.475077, -0.0682351, -0.877295, 0.0, -0.224967, -0.938972, -0.260233, 0.0, -0.377929, -0.814757, -0.439705, 0.0,
+            -0.305847, 0.542333, -0.782517, 0.0, 0.26658, -0.902905, -0.337191, 0.0, 0.0275773, 0.322158, -0.946284, 0.0, 0.0185422, 0.716349, 0.697496, 0.0,
+            -0.20483, 0.978416, 0.0273371, 0.0, -0.898276, 0.373969, 0.230752, 0.0, -0.00909378, 0.546594, 0.837349, 0.0, 0.6602, -0.751089, 0.000959236, 0.0,
+            0.855301, -0.303056, 0.420259, 0.0, 0.797138, 0.0623013, -0.600574, 0.0, 0.48947, -0.866813, 0.0951509, 0.0, 0.251142, 0.674531, 0.694216, 0.0,
+            -0.578422, -0.737373, -0.348867, 0.0, -0.254689, -0.514807, 0.818601, 0.0, 0.374972, 0.761612, 0.528529, 0.0, 0.640303, -0.734271, -0.225517, 0.0,
+            -0.638076, 0.285527, 0.715075, 0.0, 0.772956, -0.15984, -0.613995, 0.0, 0.798217, -0.590628, 0.118356, 0.0, -0.986276, -0.0578337, -0.154644, 0.0,
+            -0.312988, -0.94549, 0.0899272, 0.0, -0.497338, 0.178325, 0.849032, 0.0, -0.101136, -0.981014, 0.165477, 0.0, -0.521688, 0.0553434, -0.851339, 0.0,
+            -0.786182, -0.583814, 0.202678, 0.0, -0.565191, 0.821858, -0.0714658, 0.0, 0.437895, 0.152598, -0.885981, 0.0, -0.92394, 0.353436, -0.14635, 0.0,
+            0.212189, -0.815162, -0.538969, 0.0, -0.859262, 0.143405, -0.491024, 0.0, 0.991353, 0.112814, 0.0670273, 0.0, 0.0337884, -0.979891, -0.196654, 0.0
+    };
+    public static final double[] RANDOM_VECTORS_SIMPLEXSTYLE_STANDARD = new double[RANDOM_VECTORS.length];
+    public static final double[] RANDOM_VECTORS_SIMPLEXSTYLE_SMOOTH = new double[RANDOM_VECTORS.length];
+    public static final double[] RANDOM_VECTORS_PERLIN = new double[RANDOM_VECTORS.length];
+
+    // These were computed by gradient ascent using the above gradient set.
+    private static final double NORMALIZER_SIMPLEXSTYLE_STANDARD = 0.0185703274687564875;
+    private static final double NORMALIZER_SIMPLEXSTYLE_SMOOTH = 0.17315490496873540625;
+    private static final double NORMALIZER_PERLIN = 1.7252359327388492;
+
+    // Constant multiplier to translate the range back to what it was before the normalization fix, and perform the equivalent for the simplex-style noise.
+    private static final double COMPATIBILITY_RATIO = 2 * Math.sqrt(3.0) / NORMALIZER_PERLIN;
+    static {
+        setupLegacyMode(false);
+    }
+    public static void setupLegacyMode(boolean enableLegacyRange) {
+        double legacyMultiplier = (enableLegacyRange ? COMPATIBILITY_RATIO : 1.0);
+        for (int i = 0; i < RANDOM_VECTORS.length; i++) {
+            RANDOM_VECTORS_SIMPLEXSTYLE_STANDARD[i] = RANDOM_VECTORS[i] / (legacyMultiplier * NORMALIZER_SIMPLEXSTYLE_STANDARD);
+            RANDOM_VECTORS_SIMPLEXSTYLE_SMOOTH[i] = RANDOM_VECTORS[i] / (legacyMultiplier * NORMALIZER_SIMPLEXSTYLE_SMOOTH);
+            RANDOM_VECTORS_PERLIN[i] = RANDOM_VECTORS[i] / (legacyMultiplier * NORMALIZER_PERLIN);
+        }
+    }
+
+    /**
+     * Lookup tables to 8 decision trees for the simplex-style noise. Two cubic lattices offset by (0.5, 0.5, 0.5).
+     * The current octant of the current cubic cell of the first lattice corresponds to one cell on the second.
+     * From there, at most four ("standard") or eight ("smooth") lattice vertices are found which are in range.
+     */
+    public static final LatticePointBCC[] LOOKUP_SIMPLEXSTYLE_STANDARD = new LatticePointBCC[8];
+    public static final LatticePointBCC[] LOOKUP_SIMPLEXSTYLE_SMOOTH = new LatticePointBCC[8];
+    static {
+        for (int i = 0; i < 8; i++) {
+            int i1, j1, k1, i2, j2, k2;
+            i1 = (i >> 0) & 1; j1 = (i >> 1) & 1; k1 = (i >> 2) & 1;
+            i2 = i1 ^ 1; j2 = j1 ^ 1; k2 = k1 ^ 1;
+
+            /*
+             * Quality: Standard. Resolve nearest 4 points.
+             */
+
+            // The two points within this octant, one from each of the two cubic half-lattices.
+            LatticePointBCC csf0 = new LatticePointBCC(i1, j1, k1, 0);
+            LatticePointBCC csf1 = new LatticePointBCC(i1 + i2, j1 + j2, k1 + k2, 1);
+
+            // Each single step away on the first half-lattice.
+            LatticePointBCC csf2 = new LatticePointBCC(i1 ^ 1, j1, k1, 0);
+            LatticePointBCC csf3 = new LatticePointBCC(i1, j1 ^ 1, k1, 0);
+            LatticePointBCC csf4 = new LatticePointBCC(i1, j1, k1 ^ 1, 0);
+
+            // Each single step away on the second half-lattice.
+            LatticePointBCC csf5 = new LatticePointBCC(i1 + (i2 ^ 1), j1 + j2, k1 + k2, 1);
+            LatticePointBCC csf6 = new LatticePointBCC(i1 + i2, j1 + (j2 ^ 1), k1 + k2, 1);
+            LatticePointBCC csf7 = new LatticePointBCC(i1 + i2, j1 + j2, k1 + (k2 ^ 1), 1);
+
+            // First two are guaranteed.
+            csf0.nextOnFailure = csf0.nextOnSuccess = csf1;
+            csf1.nextOnFailure = csf1.nextOnSuccess = csf2;
+
+            // Once we find one on the first half-lattice, the rest are out.
+            // In addition, knowing csf2 rules out csf5.
+            csf2.nextOnFailure = csf3; csf2.nextOnSuccess = csf6;
+            csf3.nextOnFailure = csf4; csf3.nextOnSuccess = csf5;
+            csf4.nextOnFailure = csf4.nextOnSuccess = csf5;
+
+            // Once we find one on the second half-lattice, the rest are out.
+            csf5.nextOnFailure = csf6; csf5.nextOnSuccess = null;
+            csf6.nextOnFailure = csf7; csf6.nextOnSuccess = null;
+            csf7.nextOnFailure = csf7.nextOnSuccess = null;
+
+            LOOKUP_SIMPLEXSTYLE_STANDARD[i] = csf0;
+
+            /*
+             * Quality: Smooth. Resolve nearest 8 points.
+             */
+
+            // The two points within this octant, one from each of the two cubic half-lattices.
+            LatticePointBCC css0 = new LatticePointBCC(i1, j1, k1, 0);
+            LatticePointBCC css1 = new LatticePointBCC(i1 + i2, j1 + j2, k1 + k2, 1);
+
+            // (1, 0, 0) vs (0, 1, 1) away from octant.
+            LatticePointBCC css2 = new LatticePointBCC(i1 ^ 1, j1, k1, 0);
+            LatticePointBCC css3 = new LatticePointBCC(i1, j1 ^ 1, k1 ^ 1, 0);
+
+            // (1, 0, 0) vs (0, 1, 1) away from octant, on second half-lattice.
+            LatticePointBCC css4 = new LatticePointBCC(i1 + (i2 ^ 1), j1 + j2, k1 + k2, 1);
+            LatticePointBCC css5 = new LatticePointBCC(i1 + i2, j1 + (j2 ^ 1), k1 + (k2 ^ 1), 1);
+
+            // (0, 1, 0) vs (1, 0, 1) away from octant.
+            LatticePointBCC css6 = new LatticePointBCC(i1, j1 ^ 1, k1, 0);
+            LatticePointBCC css7 = new LatticePointBCC(i1 ^ 1, j1, k1 ^ 1, 0);
+
+            // (0, 1, 0) vs (1, 0, 1) away from octant, on second half-lattice.
+            LatticePointBCC css8 = new LatticePointBCC(i1 + i2, j1 + (j2 ^ 1), k1 + k2, 1);
+            LatticePointBCC css9 = new LatticePointBCC(i1 + (i2 ^ 1), j1 + j2, k1 + (k2 ^ 1), 1);
+
+            // (0, 0, 1) vs (1, 1, 0) away from octant.
+            LatticePointBCC cssA = new LatticePointBCC(i1, j1, k1 ^ 1, 0);
+            LatticePointBCC cssB = new LatticePointBCC(i1 ^ 1, j1 ^ 1, k1, 0);
+
+            // (0, 0, 1) vs (1, 1, 0) away from octant, on second half-lattice.
+            LatticePointBCC cssC = new LatticePointBCC(i1 + i2, j1 + j2, k1 + (k2 ^ 1), 1);
+            LatticePointBCC cssD = new LatticePointBCC(i1 + (i2 ^ 1), j1 + (j2 ^ 1), k1 + k2, 1);
+
+            // First two points are guaranteed.
+            css0.nextOnFailure = css0.nextOnSuccess = css1;
+            css1.nextOnFailure = css1.nextOnSuccess = css2;
+
+            // If css2 is in range, then we know css3 and css4 are not.
+            css2.nextOnFailure = css3; css2.nextOnSuccess = css5;
+            css3.nextOnFailure = css4; css3.nextOnSuccess = css4;
+
+            // If css4 is in range, then we know css5 is not.
+            css4.nextOnFailure = css5; css4.nextOnSuccess = css6;
+            css5.nextOnFailure = css5.nextOnSuccess = css6;
+
+            // If css6 is in range, then we know css7 and css8 are not.
+            css6.nextOnFailure = css7; css6.nextOnSuccess = css9;
+            css7.nextOnFailure = css8; css7.nextOnSuccess = css8;
+
+            // If css8 is in range, then we know css9 is not.
+            css8.nextOnFailure = css9; css8.nextOnSuccess = cssA;
+            css9.nextOnFailure = css9.nextOnSuccess = cssA;
+
+            // If cssA is in range, then we know cssB and cssC are not.
+            cssA.nextOnFailure = cssB; cssA.nextOnSuccess = cssD;
+            cssB.nextOnFailure = cssC; cssB.nextOnSuccess = cssC;
+
+            // If cssC is in range, then we know cssD is not.
+            cssC.nextOnFailure = cssD; cssC.nextOnSuccess = null;
+            cssD.nextOnFailure = cssD.nextOnSuccess = null;
+
+            LOOKUP_SIMPLEXSTYLE_SMOOTH[i] = css0;
+
+        }
+    }
+
+    /**
+     * Represents one lattice vertex on the simplex-style noise.
+     */
+    public static class LatticePointBCC {
+        public double dxr, dyr, dzr;
+        public int xrv, yrv, zrv;
+        LatticePointBCC nextOnFailure, nextOnSuccess;
+        public LatticePointBCC(int xrv, int yrv, int zrv, int lattice) {
+            this.dxr = -xrv + lattice * 0.5; this.dyr = -yrv + lattice * 0.5; this.dzr = -zrv + lattice * 0.5;
+            this.xrv = xrv + lattice * 0x8000; this.yrv = yrv + lattice * 0x8000; this.zrv = zrv + lattice * 0x8000;
+        }
+    }
+}
diff --git a/src/main/java/net/yatopia/server/exception/NoModuleException.java b/src/main/java/net/yatopia/server/exception/NoModuleException.java
new file mode 100644
index 0000000000000000000000000000000000000000..048ca20a266a714859813ef344f28fcdccce6e40
--- /dev/null
+++ b/src/main/java/net/yatopia/server/exception/NoModuleException.java
@@ -0,0 +1,34 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.exception;
+
+public class NoModuleException extends NoiseException {
+    private static final long serialVersionUID = 1;
+}
diff --git a/src/main/java/net/yatopia/server/exception/NoiseException.java b/src/main/java/net/yatopia/server/exception/NoiseException.java
new file mode 100644
index 0000000000000000000000000000000000000000..47375a0abbd03f37f2a07f43277c441766a4a948
--- /dev/null
+++ b/src/main/java/net/yatopia/server/exception/NoiseException.java
@@ -0,0 +1,34 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.exception;
+
+public class NoiseException extends RuntimeException {
+    private static final long serialVersionUID = 1;
+}
diff --git a/src/main/java/net/yatopia/server/model/Cylinder.java b/src/main/java/net/yatopia/server/model/Cylinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..d356cdb2ab11087152434818cbd2591c3e847e32
--- /dev/null
+++ b/src/main/java/net/yatopia/server/model/Cylinder.java
@@ -0,0 +1,89 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.model;
+
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * Model that defines the surface of a cylinder.
+ */
+public class Cylinder {
+    private Module module;
+
+    /**
+     * @param mod The noise module that is used to generate the output values.
+     */
+    public Cylinder(Module mod) {
+        this.module = mod;
+    }
+
+    /**
+     * Returns the noise module that is used to generate the output values.
+     *
+     * @return A reference to the noise module.
+     */
+    public Module getModule() {
+        return this.module;
+    }
+
+    /**
+     * Sets the noise module that is used to generate the output values.
+     *
+     * @param mod The noise module that is used to generate the output values.
+     * <p/>
+     * This noise module must exist for the lifetime of this object, until you pass a new noise module to this method.
+     */
+    public void setModule(Module mod) {
+        if (mod == null) {
+            throw new IllegalArgumentException("Mod cannot be null");
+        }
+        this.module = mod;
+    }
+
+    /**
+     * Returns the output value from the noise module given the (angle, height) coordinates of the specified input value located on the surface of the cylinder.
+     *
+     * @param angle The angle around the cylinder's center, in degrees.
+     * @param height The height along the @a y axis.
+     * @return The output value from the noise module.
+     */
+    public double getValue(double angle, double height) {
+        if (module == null) {
+            throw new NoModuleException();
+        }
+
+        double x, y, z;
+        x = Math.cos(Math.toRadians(angle));
+        y = height;
+        z = Math.sin(Math.toRadians(angle));
+        return module.getValue(x, y, z);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/model/Line.java b/src/main/java/net/yatopia/server/model/Line.java
new file mode 100644
index 0000000000000000000000000000000000000000..09b51ab304fd7cc4f399973176b81c8eac648531
--- /dev/null
+++ b/src/main/java/net/yatopia/server/model/Line.java
@@ -0,0 +1,160 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.model;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * Model that defines the displacement of a line segment.
+ * <p/>
+ * This model returns an output value from a noise module given the one-dimensional coordinate of an input value located on a line segment, which can be used as displacements.
+ * <p/>
+ * This class is useful for creating: - roads and rivers - disaffected college students
+ * <p/>
+ * To generate an output value, pass an input value between 0.0 and 1.0 to the GetValue() method. 0.0 represents the start position of the line segment and 1.0 represents the end position of the line
+ * segment.
+ */
+public class Line {
+    // A flag that specifies whether the value is to be attenuated
+    // (moved toward 0.0) as the ends of the line segment are approached.
+    private boolean attenuate = false;
+    // A pointer to the noise module used to generate the output values.
+    private Module module;
+    // @a x coordinate of the start of the line segment.
+    private double x0 = 0;
+    // @a x coordinate of the end of the line segment.
+    private double x1 = 1;
+    // @a y coordinate of the start of the line segment.
+    private double y0 = 0;
+    // @a y coordinate of the end of the line segment.
+    private double y1 = 1;
+    // @a z coordinate of the start of the line segment.
+    private double z0 = 0;
+    // @a z coordinate of the end of the line segment.
+    private double z1 = 1;
+
+    /**
+     * @param module The noise module that is used to generate the output values.
+     */
+    public Line(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("module cannot be null");
+        }
+        this.module = module;
+    }
+
+    /**
+     * Returns a flag indicating whether the output value is to be attenuated (moved toward 0.0) as the ends of the line segment are approached by the input value.
+     *
+     * @return true if the value is to be attenuated false if not.
+     */
+    public boolean attenuate() {
+        return this.attenuate;
+    }
+
+    /**
+     * Sets a flag indicating that the output value is to be attenuated (moved toward 0.0) as the ends of the line segment are approached.
+     *
+     * @param att A flag that specifies whether the output value is to be attenuated.
+     */
+    public void setAttenuate(boolean att) {
+        this.attenuate = att;
+    }
+
+    /**
+     * Sets the position ( @a x, @a y, @a z ) of the start of the line segment to choose values along.
+     *
+     * @param x x coordinate of the start position.
+     * @param y y coordinate of the start position.
+     * @param z z coordinate of the start position.
+     */
+    public void setStartPoint(double x, double y, double z) {
+        this.x0 = x;
+        this.y0 = y;
+        this.z0 = z;
+    }
+
+    /**
+     * Sets the position ( @a x, @a y, @a z ) of the end of the line segment to choose values along.
+     *
+     * @param x x coordinate of the end position.
+     * @param y y coordinate of the end position.
+     * @param z z coordinate of the end position.
+     */
+    public void setEndPoint(double x, double y, double z) {
+        this.x1 = x;
+        this.y1 = y;
+        this.z1 = z;
+    }
+
+    /**
+     * Returns the noise module that is used to generate the output values.
+     */
+    public Module getModule() {
+        return module;
+    }
+
+    /**
+     * Sets the noise module that is used to generate the output values.
+     *
+     * @param module The noise module that is used to generate the output values.
+     * <p/>
+     * This noise module must exist for the lifetime of this object, until you pass a new noise module to this method.
+     */
+    public void setModule(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("module cannot be null");
+        }
+        this.module = module;
+    }
+
+    /**
+     * Returns the output value from the noise module given the one-dimensional coordinate of the specified input value located on the line segment.
+     *
+     * @param p The distance along the line segment (ranges from 0.0 to 1.0)
+     * @return The output value from the noise module.
+     */
+    public double getValue(double p) {
+        if (module == null) {
+            throw new NoModuleException();
+        }
+
+        double x = (x1 - x0) * p + x0;
+        double y = (y1 - y0) * p + y0;
+        double z = (z1 - z0) * p + z0;
+        double value = module.getValue(x, y, z);
+
+        if (attenuate) {
+            return p * (1.0 - p) * 4 * value;
+        } else {
+            return value;
+        }
+    }
+}
diff --git a/src/main/java/net/yatopia/server/model/Plane.java b/src/main/java/net/yatopia/server/model/Plane.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d0d7870db2d255330375381ebc5d89a9e3e0149
--- /dev/null
+++ b/src/main/java/net/yatopia/server/model/Plane.java
@@ -0,0 +1,88 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.model;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * Model that defines the surface of a plane.
+ * <p/>
+ * This model returns an output value from a noise module given the coordinates of an input value located on the surface of an ( @a x,
+ */
+public class Plane {
+    private Module module;
+
+    /**
+     * Constructor
+     *
+     * @param module The noise module that is used to generate the output values.
+     */
+    public Plane(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("module cannot be null");
+        }
+        this.module = module;
+    }
+
+    /**
+     * Returns the noise module that is used to generate the output values.
+     */
+    public Module getModule() {
+        return module;
+    }
+
+    /**
+     * Sets the noise module that is used to generate the output values.
+     *
+     * @param module The noise module that is used to generate the output values.
+     * <p/>
+     * This noise module must exist for the lifetime of this object, until you pass a new noise module to this method.
+     */
+    public void setModule(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("module cannot be null");
+        }
+        this.module = module;
+    }
+
+    /**
+     * Returns the output value from the noise module given the ( @a x, @a z ) coordinates of the specified input value located on the surface of the plane.
+     *
+     * @param x The @a x coordinate of the input value.
+     * @param z The @a z coordinate of the input value.
+     * @return The output value from the noise module.
+     */
+    public double getValue(double x, double z) {
+        if (module == null) {
+            throw new NoModuleException();
+        }
+        return module.getValue(x, 0, z);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/model/Sphere.java b/src/main/java/net/yatopia/server/model/Sphere.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a3b1f23f1e3095ce165f7203571d7f14a47bc88
--- /dev/null
+++ b/src/main/java/net/yatopia/server/model/Sphere.java
@@ -0,0 +1,88 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.model;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * Model that defines the surface of a sphere.
+ */
+public class Sphere {
+    private Module module;
+
+    /**
+     * Constructor
+     *
+     * @param module The noise module that is used to generate the output values.
+     */
+    public Sphere(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("module cannot be null");
+        }
+        this.module = module;
+    }
+
+    /**
+     * Returns the noise module that is used to generate the output values.
+     */
+    public Module getModule() {
+        return module;
+    }
+
+    /**
+     * Sets the noise module that is used to generate the output values.
+     *
+     * @param module The noise module that is used to generate the output values.
+     *
+     * This noise module must exist for the lifetime of this object, until you pass a new noise module to this method.
+     */
+    public void setModule(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("module cannot be null");
+        }
+        this.module = module;
+    }
+
+    /**
+     * Returns the output value from the noise module given the (latitude, longitude) coordinates of the specified input value located on the surface of the sphere.
+     *
+     * @param lat The latitude of the input value, in degrees.
+     * @param lon The longitude of the input value, in degrees.
+     * @return The output value from the noise module.
+     */
+    public double getValue(double lat, double lon) {
+        if (module == null) {
+            throw new NoModuleException();
+        }
+        double[] vec = Utils.latLonToXYZ(lat, lon);
+        return module.getValue(vec[0], vec[1], vec[2]);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/Cache.java b/src/main/java/net/yatopia/server/module/Cache.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e080021dfbfafbd9b0b4457003d539fb7c1b0b9
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/Cache.java
@@ -0,0 +1,78 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module;
+
+
+import org.spongepowered.noise.exception.NoModuleException;
+
+public class Cache extends Module {
+    // The cached output value at the cached input value.
+    private double cachedValue;
+    // Determines if a cached output value is stored in this noise
+    // module.
+    private boolean isCached = false;
+    // @a x coordinate of the cached input value.
+    private double xCache;
+    // @a y coordinate of the cached input value.
+    private double yCache;
+    // @a z coordinate of the cached input value.
+    private double zCache;
+
+    public Cache() {
+        super(1);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public void setSourceModule(int index, Module sourceModule) {
+        super.setSourceModule(index, sourceModule);
+        isCached = false;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        if (!(isCached && x == xCache && y == yCache && z == zCache)) {
+            cachedValue = sourceModule[0].getValue(x, y, z);
+            xCache = x;
+            yCache = y;
+            zCache = z;
+        }
+        isCached = true;
+        return cachedValue;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/Module.java b/src/main/java/net/yatopia/server/module/Module.java
new file mode 100644
index 0000000000000000000000000000000000000000..195a0e7812e5db8e8c436ae1ea9af129e5860261
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/Module.java
@@ -0,0 +1,72 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module;
+
+import org.spongepowered.noise.exception.NoModuleException;
+
+public abstract class Module {
+    protected Module[] sourceModule;
+
+    public Module(int sourceModuleCount) {
+        sourceModule = null;
+
+        // Create an array of pointers to all source modules required by this
+        // noise module.  Set these pointers to NULL.
+        if (sourceModuleCount > 0) {
+            sourceModule = new Module[sourceModuleCount];
+            for (int i = 0; i < sourceModuleCount; i++) {
+                sourceModule[i] = null;
+            }
+        } else {
+            sourceModule = null;
+        }
+    }
+
+    public Module getSourceModule(int index) {
+        if (index >= getSourceModuleCount() || index < 0 || sourceModule[index] == null) {
+            throw new NoModuleException();
+        }
+        return (sourceModule[index]);
+    }
+
+    public void setSourceModule(int index, Module sourceModule) {
+        if (this.sourceModule == null) {
+            return;
+        }
+        if (index >= getSourceModuleCount() || index < 0) {
+            throw new IllegalArgumentException("Index must be between 0 and GetSourceModuleCount()");
+        }
+        this.sourceModule[index] = sourceModule;
+    }
+
+    public abstract int getSourceModuleCount();
+
+    public abstract double getValue(double x, double y, double z);
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Add.java b/src/main/java/net/yatopia/server/module/combiner/Add.java
new file mode 100644
index 0000000000000000000000000000000000000000..10a033f589e057db7e646dddd73a5a292f1229f9
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Add.java
@@ -0,0 +1,55 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.combiner;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Add extends Module {
+    public Add() {
+        super(2);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 2;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+        return sourceModule[0].getValue(x, y, z) + sourceModule[1].getValue(x, y, z);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Blend.java b/src/main/java/net/yatopia/server/module/combiner/Blend.java
new file mode 100644
index 0000000000000000000000000000000000000000..534235e51bf277cdaf12f27be2bf31be622e2455
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Blend.java
@@ -0,0 +1,77 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.combiner;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Blend extends Module {
+    public Blend() {
+        super(3);
+    }
+
+    public Module getControlModule() {
+        if (sourceModule[2] == null) {
+            throw new NoModuleException();
+        }
+        return sourceModule[2];
+    }
+
+    public void setControlModule(Module module) {
+        if (module == null) {
+            throw new IllegalArgumentException("Control Module cannot be null");
+        }
+        sourceModule[2] = module;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 3;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[2] == null) {
+            throw new NoModuleException();
+        }
+
+        double v0 = sourceModule[0].getValue(x, y, z);
+        double v1 = sourceModule[1].getValue(x, y, z);
+        double alpha = sourceModule[2].getValue(x, y, z);
+        return Utils.linearInterp(v0, v1, alpha);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Displace.java b/src/main/java/net/yatopia/server/module/combiner/Displace.java
new file mode 100644
index 0000000000000000000000000000000000000000..c83a800a9e5bb4843153d481bb65dd9774663cda
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Displace.java
@@ -0,0 +1,117 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.combiner;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Displace extends Module {
+    public Displace() {
+        super(4);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 4;
+    }
+
+    public Module getXDisplaceModule() {
+        if (sourceModule == null || sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+        return sourceModule[1];
+    }
+
+    public Module getYDisplaceModule() {
+        if (sourceModule == null || sourceModule[2] == null) {
+            throw new NoModuleException();
+        }
+        return sourceModule[2];
+    }
+
+    public Module getZDisplaceModule() {
+        if (sourceModule == null || sourceModule[3] == null) {
+            throw new NoModuleException();
+        }
+        return sourceModule[3];
+    }
+
+    public void setXDisplaceModule(Module x) {
+        if (x == null) {
+            throw new IllegalArgumentException("x cannot be null");
+        }
+        sourceModule[1] = x;
+    }
+
+    public void setYDisplaceModule(Module y) {
+        if (y == null) {
+            throw new IllegalArgumentException("y cannot be null");
+        }
+        sourceModule[2] = y;
+    }
+
+    public void setZDisplaceModule(Module z) {
+        if (z == null) {
+            throw new IllegalArgumentException("z cannot be null");
+        }
+        sourceModule[3] = z;
+    }
+
+    public void setDisplaceModules(Module x, Module y, Module z) {
+        setXDisplaceModule(x);
+        setYDisplaceModule(y);
+        setZDisplaceModule(z);
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[2] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[3] == null) {
+            throw new NoModuleException();
+        }
+
+        // Get the output values from the three displacement modules.  Add each
+        // value to the corresponding coordinate in the input value.
+        double xDisplace = x + sourceModule[1].getValue(x, y, z);
+        double yDisplace = y + sourceModule[2].getValue(x, y, z);
+        double zDisplace = z + sourceModule[3].getValue(x, y, z);
+
+        // Retrieve the output value using the offset input value instead of
+        // the original input value.
+        return sourceModule[0].getValue(xDisplace, yDisplace, zDisplace);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Max.java b/src/main/java/net/yatopia/server/module/combiner/Max.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6e5a4c5112c4495b85f57258d1b5a4582cddd9c
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Max.java
@@ -0,0 +1,58 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.combiner;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Max extends Module {
+    public Max() {
+        super(2);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 2;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+
+        double v0 = sourceModule[0].getValue(x, y, z);
+        double v1 = sourceModule[1].getValue(x, y, z);
+        return Math.max(v0, v1);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Min.java b/src/main/java/net/yatopia/server/module/combiner/Min.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e3bce594fe0fe3e294968d1dc0387ee754ef4b8
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Min.java
@@ -0,0 +1,58 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.combiner;
+
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Min extends Module {
+    public Min() {
+        super(2);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 2;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+
+        double v0 = sourceModule[0].getValue(x, y, z);
+        double v1 = sourceModule[1].getValue(x, y, z);
+        return Math.min(v0, v1);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Multiply.java b/src/main/java/net/yatopia/server/module/combiner/Multiply.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7b75bcd9528952e7b98b32a9c42e180b0dcb332
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Multiply.java
@@ -0,0 +1,56 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.combiner;
+
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Multiply extends Module {
+    public Multiply() {
+        super(2);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 2;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+
+        return sourceModule[0].getValue(x, y, z) * sourceModule[1].getValue(x, y, z);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Power.java b/src/main/java/net/yatopia/server/module/combiner/Power.java
new file mode 100644
index 0000000000000000000000000000000000000000..c28eb9546307f139c3f9da676c8c5963bc4907d7
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Power.java
@@ -0,0 +1,55 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.combiner;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Power extends Module {
+    public Power() {
+        super(2);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 2;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+
+        return Math.pow(sourceModule[0].getValue(x, y, z), sourceModule[1].getValue(x, y, z));
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/combiner/Select.java b/src/main/java/net/yatopia/server/module/combiner/Select.java
new file mode 100644
index 0000000000000000000000000000000000000000..6de4d1076e529db27d82e5a7385fe0c9545707fc
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/combiner/Select.java
@@ -0,0 +1,155 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.combiner;
+
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Select extends Module {
+    // Default edge-falloff value for the noise::module::Select noise module.
+    public static final double DEFAULT_SELECT_EDGE_FALLOFF = 0.0;
+    // Default lower bound of the selection range for the
+    // noise::module::Select noise module.
+    public static final double DEFAULT_SELECT_LOWER_BOUND = -1.0;
+    // Default upper bound of the selection range for the
+    // noise::module::Select noise module.
+    public static final double DEFAULT_SELECT_UPPER_BOUND = 1.0;
+    // Edge-falloff value.
+    private double edgeFalloff = DEFAULT_SELECT_EDGE_FALLOFF;
+    // Lower bound of the selection range.
+    private double lowerBound = DEFAULT_SELECT_LOWER_BOUND;
+    // Upper bound of the selection range.
+    private double upperBound = DEFAULT_SELECT_UPPER_BOUND;
+
+    public Select() {
+        super(3);
+    }
+
+    public Module getControlModule() {
+        if (sourceModule == null || sourceModule[2] == null) {
+            throw new NoModuleException();
+        }
+        return sourceModule[2];
+    }
+
+    public void setControlModule(Module m) {
+        if (m == null) {
+            throw new IllegalArgumentException("the module cannot be null");
+        }
+        sourceModule[2] = m;
+    }
+
+    public double getEdgeFalloff() {
+        return edgeFalloff;
+    }
+
+    public void setEdgeFalloff(double edgeFalloff) {
+        // Make sure that the edge falloff curves do not overlap.
+        double boundSize = upperBound - lowerBound;
+        this.edgeFalloff = (edgeFalloff > boundSize / 2) ? boundSize / 2 : edgeFalloff;
+    }
+
+    public double getLowerBound() {
+        return lowerBound;
+    }
+
+    public double getUpperBound() {
+        return upperBound;
+    }
+
+    public void setBounds(double upper, double lower) {
+        if (lower > upper) {
+            throw new IllegalArgumentException("lower must be less than upper");
+        }
+        this.lowerBound = lower;
+        this.upperBound = upper;
+
+        setEdgeFalloff(edgeFalloff);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 3;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[1] == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[2] == null) {
+            throw new NoModuleException();
+        }
+
+        double controlValue = sourceModule[2].getValue(x, y, z);
+        double alpha;
+        if (edgeFalloff > 0.0) {
+            if (controlValue < (lowerBound - edgeFalloff)) {
+                // The output value from the control module is below the selector
+                // threshold; return the output value from the first source module.
+                return sourceModule[0].getValue(x, y, z);
+            } else if (controlValue < (lowerBound + edgeFalloff)) {
+                // The output value from the control module is near the lower end of the
+                // selector threshold and within the smooth curve. Interpolate between
+                // the output values from the first and second source modules.
+                double lowerCurve = (lowerBound - edgeFalloff);
+                double upperCurve = (lowerBound + edgeFalloff);
+                alpha = Utils.sCurve3((controlValue - lowerCurve) / (upperCurve - lowerCurve));
+                return Utils.linearInterp(sourceModule[0].getValue(x, y, z), sourceModule[1].getValue(x, y, z), alpha);
+            } else if (controlValue < (upperBound - edgeFalloff)) {
+                // The output value from the control module is within the selector
+                // threshold; return the output value from the second source module.
+                return sourceModule[1].getValue(x, y, z);
+            } else if (controlValue < (upperBound + edgeFalloff)) {
+                // The output value from the control module is near the upper end of the
+                // selector threshold and within the smooth curve. Interpolate between
+                // the output values from the first and second source modules.
+                double lowerCurve = (upperBound - edgeFalloff);
+                double upperCurve = (upperBound + edgeFalloff);
+                alpha = Utils.sCurve3((controlValue - lowerCurve) / (upperCurve - lowerCurve));
+                return Utils.linearInterp(sourceModule[1].getValue(x, y, z), sourceModule[0].getValue(x, y, z), alpha);
+            } else {
+                // Output value from the control module is above the selector threshold;
+                // return the output value from the first source module.
+                return sourceModule[0].getValue(x, y, z);
+            }
+        } else {
+            if (controlValue < lowerBound || controlValue > upperBound) {
+                return sourceModule[0].getValue(x, y, z);
+            } else {
+                return sourceModule[1].getValue(x, y, z);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Abs.java b/src/main/java/net/yatopia/server/module/modifier/Abs.java
new file mode 100644
index 0000000000000000000000000000000000000000..76013789f0e972e0b01763248e3352b68a85deb0
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Abs.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Abs extends Module {
+    public Abs() {
+        super(1);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule == null) {
+            throw new NoModuleException();
+        }
+        return Math.abs(sourceModule[0].getValue(x, y, z));
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Clamp.java b/src/main/java/net/yatopia/server/module/modifier/Clamp.java
new file mode 100644
index 0000000000000000000000000000000000000000..09af624756f2abea19ecb82602f329dcdd05ed3a
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Clamp.java
@@ -0,0 +1,80 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Clamp extends Module {
+    public static final double DEFAULT_LOWER_BOUND = 0.0;
+    public static final double DEFAULT_UPPER_BOUND = 1.0;
+    private double lowerBound = DEFAULT_LOWER_BOUND;
+    private double upperBound = DEFAULT_UPPER_BOUND;
+
+    public Clamp() {
+        super(1);
+    }
+
+    public double getLowerBound() {
+        return lowerBound;
+    }
+
+    public void setLowerBound(double lowerBound) {
+        this.lowerBound = lowerBound;
+    }
+
+    public double getUpperBound() {
+        return upperBound;
+    }
+
+    public void setUpperBound(double upperBound) {
+        this.upperBound = upperBound;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        double value = sourceModule[0].getValue(x, y, z);
+        if (value < lowerBound) {
+            return lowerBound;
+        } else if (value > upperBound) {
+            return upperBound;
+        } else {
+            return value;
+        }
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Curve.java b/src/main/java/net/yatopia/server/module/modifier/Curve.java
new file mode 100644
index 0000000000000000000000000000000000000000..30eb653a34344c8e649e87c90c62de33a2726cb5
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Curve.java
@@ -0,0 +1,139 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Curve extends Module {
+    private final List<ControlPoint> controlPoints = new ArrayList<>();
+
+    public Curve() {
+        super(1);
+    }
+
+    public void addControlPoint(double inputValue, double outputValue) {
+        int index = findInsertionPos(inputValue);
+        insertAtPos(index, inputValue, outputValue);
+    }
+
+    public ControlPoint[] getControlPoints() {
+        return (ControlPoint[]) controlPoints.toArray();
+    }
+
+    public void clearAllControlPoints() {
+        controlPoints.clear();
+    }
+
+    private int findInsertionPos(double inputValue) {
+        int insertionPos;
+        for (insertionPos = 0; insertionPos < controlPoints.size(); insertionPos++) {
+            if (inputValue < controlPoints.get(insertionPos).inputValue) {
+                // We found the array index in which to insert the new control point.
+                // Exit now.
+                break;
+            } else if (inputValue == controlPoints.get(insertionPos).inputValue) {
+                // Each control point is required to contain a unique input value, so
+                // throw an exception.
+                throw new IllegalArgumentException("inputValue must be unique");
+            }
+        }
+        return insertionPos;
+    }
+
+    private void insertAtPos(int insertionPos, double inputValue, double outputValue) {
+        ControlPoint newPoint = new ControlPoint();
+        newPoint.inputValue = inputValue;
+        newPoint.outputValue = outputValue;
+        controlPoints.add(insertionPos, newPoint);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        final int size = controlPoints.size();
+        if (size < 4) {
+            throw new RuntimeException("Curve module must have at least 4 control points");
+        }
+
+        // Get the output value from the source module.
+        double sourceModuleValue = sourceModule[0].getValue(x, y, z);
+
+        // Find the first element in the control point array that has an input value
+        // larger than the output value from the source module.
+        int indexPos;
+        for (indexPos = 0; indexPos < size; indexPos++) {
+            if (sourceModuleValue < controlPoints.get(indexPos).inputValue) {
+                break;
+            }
+        }
+
+        // Find the four nearest control points so that we can perform cubic
+        // interpolation.
+        final int lastIndex = size - 1;
+        int index0 = Utils.clamp(indexPos - 2, 0, lastIndex);
+        int index1 = Utils.clamp(indexPos - 1, 0, lastIndex);
+        int index2 = Utils.clamp(indexPos, 0, lastIndex);
+        int index3 = Utils.clamp(indexPos + 1, 0, lastIndex);
+
+        // If some control points are missing (which occurs if the value from the
+        // source module is greater than the largest input value or less than the
+        // smallest input value of the control point array), get the corresponding
+        // output value of the nearest control point and exit now.
+        if (index1 == index2) {
+            return controlPoints.get(index1).outputValue;
+        }
+
+        // Compute the alpha value used for cubic interpolation.
+        double input0 = controlPoints.get(index1).inputValue;
+        double input1 = controlPoints.get(index2).inputValue;
+        double alpha = (sourceModuleValue - input0) / (input1 - input0);
+
+        // Now perform the cubic interpolation given the alpha value.
+        return Utils.cubicInterp(controlPoints.get(index0).outputValue, controlPoints.get(index1).outputValue, controlPoints.get(index2).outputValue, controlPoints.get(index3).outputValue, alpha);
+    }
+
+    public static class ControlPoint {
+        private double inputValue;
+        private double outputValue;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Exponent.java b/src/main/java/net/yatopia/server/module/modifier/Exponent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d86838ed9976af01a5962b42c0c57a0dedecf67
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Exponent.java
@@ -0,0 +1,63 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Exponent extends Module {
+    public static final double DEFAULT_EXPONENT = 1.0;
+    private double exponent = DEFAULT_EXPONENT;
+
+    public Exponent() {
+        super(1);
+    }
+
+    public double getExponent() {
+        return exponent;
+    }
+
+    public void setExponent(double exponent) {
+        this.exponent = exponent;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        double value = sourceModule[0].getValue(x, y, z);
+        return Math.pow(value, exponent);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Invert.java b/src/main/java/net/yatopia/server/module/modifier/Invert.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae94a74719df2d32d19a0dab87b5634ef08c74d3
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Invert.java
@@ -0,0 +1,63 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Invert extends Module {
+    public static final double DEFAULT_MIDDLE = 0.0;
+    private double middle = DEFAULT_MIDDLE;
+
+    public Invert() {
+        super(1);
+    }
+
+    public double getMiddle() {
+        return middle;
+    }
+
+    public void setMiddle(double middle) {
+        this.middle = middle;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        return middle - sourceModule[0].getValue(x, y, z);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Range.java b/src/main/java/net/yatopia/server/module/modifier/Range.java
new file mode 100644
index 0000000000000000000000000000000000000000..4817da61af149c5526a545c9f57f0194d90d079e
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Range.java
@@ -0,0 +1,128 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * A modifier module to map a value from one range to another.
+ * For example: 0.5 (-1 &lt; x &lt; 1) -&gt; 0.75 (0 &lt; x &lt; 1)
+ */
+public class Range extends Module {
+    
+    public static final double DEFAULT_CURRENT_LOWER_BOUND = -1f;
+    public static final double DEFAULT_CURRENT_UPPER_BOUND = 1f;
+    public static final double DEFAULT_NEW_LOWER_BOUND = 0f;
+    public static final double DEFAULT_NEW_UPPER_BOUND = 1f;
+    
+    /* Current lower bound */
+    private double currentLowerBound = DEFAULT_CURRENT_LOWER_BOUND;
+    /* Current upper bound */
+    private double currentUpperBound = DEFAULT_CURRENT_UPPER_BOUND;
+    /* New lower bound */
+    private double newLowerBound = DEFAULT_NEW_LOWER_BOUND;
+    /* New Upper Bound */
+    private double newUpperBound = DEFAULT_NEW_UPPER_BOUND;
+    /* Cache variables */
+    private double scale;
+    private double bias;
+
+    public Range() {
+        super(1);
+    }
+
+    public double getCurrentLowerBound() {
+        return currentLowerBound;
+    }
+
+    public double getCurrentUpperBound() {
+        return currentUpperBound;
+    }
+
+    public double getNewLowerBound() {
+        return newLowerBound;
+    }
+    
+    public double getNewUpperBound() {
+        return newUpperBound;
+    }
+    
+    /*
+     * Calculate the scale and biased to be a applied during Range#getValue(int x, int y, int z)
+     * Should be called when the bounds are modified
+     */
+    private void recalculateScaleBias() {
+    	scale = (getNewUpperBound() - getNewLowerBound()) / 
+        		(getCurrentUpperBound() - getCurrentLowerBound());
+    	bias = getNewLowerBound() - getCurrentLowerBound() * scale;
+    }
+    
+    /**
+     * Configure bounds for range module
+     * @param currentLower current lower bound
+     * @param currentUpper current upper bound
+     * @param newLower new lower bound
+     * @param newUpper new upper bound
+     */
+    public void setBounds(double currentLower, double currentUpper, double newLower,
+    		double newUpper) {
+    	if (currentLower == currentUpper) {
+    		throw new IllegalArgumentException("currentLower must not equal currentUpper. Both are " + currentUpper);
+    	}
+    	if (newLower == newUpper) {
+    		throw new IllegalArgumentException("newLowerBound must not equal newUpperBound. Both are " + newUpper);
+    	}
+    	currentLowerBound = currentLower;
+    	currentUpperBound = currentUpper;
+    	newLowerBound = newLower;
+    	newUpperBound = newUpper;
+    	recalculateScaleBias();
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule == null) {
+            throw new NoModuleException();
+        }
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+        
+        double oldVal = sourceModule[0].getValue(x, y, z);
+        return oldVal * scale + bias;
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/RotatePoint.java b/src/main/java/net/yatopia/server/module/modifier/RotatePoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..16c3924c128601863b2fc87a317178c6c46c214b
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/RotatePoint.java
@@ -0,0 +1,145 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class RotatePoint extends Module {
+    // Default @a x rotation angle for the noise::module::RotatePoint noise
+    // module.
+    public static final double DEFAULT_ROTATE_X = 0.0;
+    // Default @a y rotation angle for the noise::module::RotatePoint noise
+    // module.
+    public static final double DEFAULT_ROTATE_Y = 0.0;
+    // Default @a z rotation angle for the noise::module::RotatePoint noise
+    // module.
+    public static final double DEFAULT_ROTATE_Z = 0.0;
+    private double xAngle = DEFAULT_ROTATE_X;
+    private double yAngle = DEFAULT_ROTATE_Y;
+    private double zAngle = DEFAULT_ROTATE_Z;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double x1Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double x2Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double x3Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double y1Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double y2Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double y3Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double z1Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double z2Matrix;
+    // An entry within the 3x3 rotation matrix used for rotating the
+    // input value.
+    private double z3Matrix;
+
+    public RotatePoint() {
+        super(1);
+        setAngles(DEFAULT_ROTATE_X, DEFAULT_ROTATE_Y, DEFAULT_ROTATE_Z);
+    }
+
+    public void setAngles(double x, double y, double z) {
+        double xCos, yCos, zCos, xSin, ySin, zSin;
+        xCos = Math.cos(Math.toRadians(x));
+        yCos = Math.cos(Math.toRadians(y));
+        zCos = Math.cos(Math.toRadians(z));
+        xSin = Math.sin(Math.toRadians(x));
+        ySin = Math.sin(Math.toRadians(y));
+        zSin = Math.sin(Math.toRadians(z));
+
+        x1Matrix = ySin * xSin * zSin + yCos * zCos;
+        y1Matrix = xCos * zSin;
+        z1Matrix = ySin * zCos - yCos * xSin * zSin;
+        x2Matrix = ySin * xSin * zCos - yCos * zSin;
+        y2Matrix = xCos * zCos;
+        z2Matrix = -yCos * xSin * zCos - ySin * zSin;
+        x3Matrix = -ySin * xCos;
+        y3Matrix = xSin;
+        z3Matrix = yCos * xCos;
+
+        this.xAngle = x;
+        this.yAngle = y;
+        this.zAngle = z;
+    }
+
+    public double getXAngle() {
+        return xAngle;
+    }
+
+    public void setXAngle(double xAngle) {
+        setAngles(xAngle, yAngle, zAngle);
+    }
+
+    public double getYAngle() {
+        return yAngle;
+    }
+
+    public void setYAngle(double yAngle) {
+        setAngles(xAngle, yAngle, zAngle);
+    }
+
+    public double getZAngle() {
+        return zAngle;
+    }
+
+    public void setZAngle(double zAngle) {
+        setAngles(xAngle, yAngle, zAngle);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        double nx = (x1Matrix * x) + (y1Matrix * y) + (z1Matrix * z);
+        double ny = (x2Matrix * x) + (y2Matrix * y) + (z2Matrix * z);
+        double nz = (x3Matrix * x) + (y3Matrix * y) + (z3Matrix * z);
+        return sourceModule[0].getValue(nx, ny, nz);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/ScaleBias.java b/src/main/java/net/yatopia/server/module/modifier/ScaleBias.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3fb92e1c6c40c67a124eb9e3cb0556dc5bae483
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/ScaleBias.java
@@ -0,0 +1,79 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class ScaleBias extends Module {
+    // Default bias for the noise::module::ScaleBias noise module.
+    public static final double DEFAULT_BIAS = 0.0;
+    // Default scale for the noise::module::ScaleBias noise module.
+    public static final double DEFAULT_SCALE = 1.0;
+    // Bias to apply to the scaled output value from the source module.
+    private double bias = DEFAULT_BIAS;
+    // Scaling factor to apply to the output value from the source
+    // module.
+    private double scale = DEFAULT_SCALE;
+
+    public ScaleBias() {
+        super(1);
+    }
+
+    public double getBias() {
+        return bias;
+    }
+
+    public void setBias(double bias) {
+        this.bias = bias;
+    }
+
+    public double getScale() {
+        return scale;
+    }
+
+    public void setScale(double scale) {
+        this.scale = scale;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        return sourceModule[0].getValue(x, y, z) * scale + bias;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/ScalePoint.java b/src/main/java/net/yatopia/server/module/modifier/ScalePoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ed4fa31b49f9b49a272c90104f6df3694298895
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/ScalePoint.java
@@ -0,0 +1,93 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class ScalePoint extends Module {
+    // Default scaling factor applied to the @a x coordinate for the
+    // noise::module::ScalePoint noise module.
+    public static final double DEFAULT_SCALE_POINT_X = 1.0;
+    // Default scaling factor applied to the @a y coordinate for the
+    // noise::module::ScalePoint noise module.
+    public static final double DEFAULT_SCALE_POINT_Y = 1.0;
+    // Default scaling factor applied to the @a z coordinate for the
+    // noise::module::ScalePoint noise module.
+    public static final double DEFAULT_SCALE_POINT_Z = 1.0;
+    // Scaling factor applied to the @a x coordinate of the input value.
+    private double xScale = DEFAULT_SCALE_POINT_X;
+    // Scaling factor applied to the @a y coordinate of the input value.
+    private double yScale = DEFAULT_SCALE_POINT_Y;
+    // Scaling factor applied to the @a z coordinate of the input value.
+    private double zScale = DEFAULT_SCALE_POINT_Z;
+
+    public ScalePoint() {
+        super(1);
+    }
+
+    public double getXScale() {
+        return xScale;
+    }
+
+    public void setXScale(double xScale) {
+        this.xScale = xScale;
+    }
+
+    public double getYScale() {
+        return yScale;
+    }
+
+    public void setYScale(double yScale) {
+        this.yScale = yScale;
+    }
+
+    public double getZScale() {
+        return zScale;
+    }
+
+    public void setZScale(double zScale) {
+        this.zScale = zScale;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        return sourceModule[0].getValue(x * xScale, y * yScale, z * zScale);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Terrace.java b/src/main/java/net/yatopia/server/module/modifier/Terrace.java
new file mode 100644
index 0000000000000000000000000000000000000000..889ff19b9c98d8740e4e065d76b94cb3e8155f0b
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Terrace.java
@@ -0,0 +1,180 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class Terrace extends Module {
+    // Number of control points stored in this noise module.
+    private int controlPointCount = 0;
+    // Determines if the terrace-forming curve between all control points
+    // is inverted.
+    private boolean invertTerraces = false;
+    // Array that stores the control points.
+    private double[] controlPoints = new double[0];
+
+    public Terrace() {
+        super(1);
+    }
+
+    public boolean isInvertTerraces() {
+        return invertTerraces;
+    }
+
+    public void setInvertTerraces(boolean invertTerraces) {
+        this.invertTerraces = invertTerraces;
+    }
+
+    public int getControlPointCount() {
+        return controlPointCount;
+    }
+
+    public double[] getControlPoints() {
+        return controlPoints;
+    }
+
+    public void addControlPoint(double value) {
+        int insertionPos = findInsertionPos(value);
+        insertAtPos(insertionPos, value);
+    }
+
+    public void clearAllControlPoints() {
+        controlPoints = null;
+        controlPointCount = 0;
+    }
+
+    public void makeControlPoints(int controlPointCount) {
+        if (controlPointCount < 2) {
+            throw new IllegalArgumentException("Must have more than 2 control points");
+        }
+
+        clearAllControlPoints();
+
+        double terraceStep = 2.0 / (controlPointCount - 1.0);
+        double curValue = -1.0;
+        for (int i = 0; i < controlPointCount; i++) {
+            addControlPoint(curValue);
+            curValue += terraceStep;
+        }
+    }
+
+    private int findInsertionPos(double value) {
+        int insertionPos;
+        for (insertionPos = 0; insertionPos < controlPointCount; insertionPos++) {
+            if (value < controlPoints[insertionPos]) {
+                // We found the array index in which to insert the new control point.
+                // Exit now.
+                break;
+            } else if (value == controlPoints[insertionPos]) {
+                // Each control point is required to contain a unique value, so throw
+                // an exception.
+                throw new IllegalArgumentException("Value must be unique");
+            }
+        }
+        return insertionPos;
+    }
+
+    private void insertAtPos(int insertionPos, double value) {
+        // Make room for the new control point at the specified position within
+        // the control point array.  The position is determined by the value of
+        // the control point; the control points must be sorted by value within
+        // that array.
+        double[] newControlPoints = new double[controlPointCount + 1];
+        for (int i = 0; i < controlPointCount; i++) {
+            if (i < insertionPos) {
+                newControlPoints[i] = controlPoints[i];
+            } else {
+                newControlPoints[i + 1] = controlPoints[i];
+            }
+        }
+
+        controlPoints = newControlPoints;
+        ++controlPointCount;
+
+        // Now that we've made room for the new control point within the array,
+        // add the new control point.
+        controlPoints[insertionPos] = value;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        // Get the output value from the source module.
+        double sourceModuleValue = sourceModule[0].getValue(x, y, z);
+
+        // Find the first element in the control point array that has a value
+        // larger than the output value from the source module.
+        int indexPos;
+        for (indexPos = 0; indexPos < controlPointCount; indexPos++) {
+            if (sourceModuleValue < controlPoints[indexPos]) {
+                break;
+            }
+        }
+
+        // Find the two nearest control points so that we can map their values
+        // onto a quadratic curve.
+        int index0 = Utils.clamp(indexPos - 1, 0, controlPointCount - 1);
+        int index1 = Utils.clamp(indexPos, 0, controlPointCount - 1);
+
+        // If some control points are missing (which occurs if the output value from
+        // the source module is greater than the largest value or less than the
+        // smallest value of the control point array), get the value of the nearest
+        // control point and exit now.
+        if (index0 == index1) {
+            return controlPoints[index1];
+        }
+
+        // Compute the alpha value used for linear interpolation.
+        double value0 = controlPoints[index0];
+        double value1 = controlPoints[index1];
+        double alpha = (sourceModuleValue - value0) / (value1 - value0);
+        if (invertTerraces) {
+            alpha = 1.0 - alpha;
+            double temp = value0;
+            value0 = value1;
+            value1 = temp;
+        }
+
+        // Squaring the alpha produces the terrace effect.
+        alpha *= alpha;
+
+        // Now perform the linear interpolation given the alpha value.
+        return Utils.linearInterp(value0, value1, alpha);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/TranslatePoint.java b/src/main/java/net/yatopia/server/module/modifier/TranslatePoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..c48863bf4e68846ea8cf8076506dc34ad3c8f454
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/TranslatePoint.java
@@ -0,0 +1,101 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+
+public class TranslatePoint extends Module {
+    // Default translation factor applied to the @a x coordinate for the
+    // noise::module::TranslatePoint noise module.
+    public static final double DEFAULT_TRANSLATE_POINT_X = 0.0;
+    // Default translation factor applied to the @a y coordinate for the
+    // noise::module::TranslatePoint noise module.
+    public static final double DEFAULT_TRANSLATE_POINT_Y = 0.0;
+    // Default translation factor applied to the @a z coordinate for the
+    // noise::module::TranslatePoint noise module.
+    public static final double DEFAULT_TRANSLATE_POINT_Z = 0.0;
+    // Translation amount applied to the @a x coordinate of the input
+    // value.
+    private double xTranslation = DEFAULT_TRANSLATE_POINT_X;
+    // Translation amount applied to the @a y coordinate of the input
+    // value.
+    private double yTranslation = DEFAULT_TRANSLATE_POINT_Y;
+    // Translation amount applied to the @a z coordinate of the input
+    // value.
+    private double zTranslation = DEFAULT_TRANSLATE_POINT_Z;
+
+    public TranslatePoint() {
+        super(1);
+    }
+
+    public double getXTranslation() {
+        return xTranslation;
+    }
+
+    public void setXTranslation(double xTranslation) {
+        this.xTranslation = xTranslation;
+    }
+
+    public double getYTranslation() {
+        return yTranslation;
+    }
+
+    public void setYTranslation(double yTranslation) {
+        this.yTranslation = yTranslation;
+    }
+
+    public double getZTranslation() {
+        return zTranslation;
+    }
+
+    public void setZTranslation(double zTranslation) {
+        this.zTranslation = zTranslation;
+    }
+
+    public void setTranslations(double x, double y, double z) {
+        setXTranslation(x);
+        setYTranslation(y);
+        setZTranslation(z);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        return sourceModule[0].getValue(x + xTranslation, y + yTranslation, z + zTranslation);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/modifier/Turbulence.java b/src/main/java/net/yatopia/server/module/modifier/Turbulence.java
new file mode 100644
index 0000000000000000000000000000000000000000..811a619a9875834571992eb220bdf8abfb1ba7b6
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/modifier/Turbulence.java
@@ -0,0 +1,130 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.modifier;
+import org.spongepowered.noise.exception.NoModuleException;
+import org.spongepowered.noise.module.Module;
+import org.spongepowered.noise.module.source.Perlin;
+
+public class Turbulence extends Module {
+    // Default power for the noise::module::Turbulence noise module.
+    public static final double DEFAULT_TURBULENCE_POWER = 1.0;
+    // The power (scale) of the displacement.
+    private double power = DEFAULT_TURBULENCE_POWER;
+    // Noise module that displaces the @a x coordinate.
+    private final Perlin xDistortModule;
+    // Noise module that displaces the @a y coordinate.
+    private final Perlin yDistortModule;
+    // Noise module that displaces the @a z coordinate.
+    private final Perlin zDistortModule;
+
+    public Turbulence() {
+        super(1);
+        xDistortModule = new Perlin();
+        yDistortModule = new Perlin();
+        zDistortModule = new Perlin();
+    }
+
+    public double getPower() {
+        return power;
+    }
+
+    public void setPower(double power) {
+        this.power = power;
+    }
+
+    public int getRoughnessCount() {
+        return xDistortModule.getOctaveCount();
+    }
+
+    public double getFrequency() {
+        return xDistortModule.getFrequency();
+    }
+
+    public int getSeed() {
+        return xDistortModule.getSeed();
+    }
+
+    public void setSeed(int seed) {
+        xDistortModule.setSeed(seed);
+        yDistortModule.setSeed(seed + 1);
+        zDistortModule.setSeed(seed + 2);
+    }
+
+    public void setFrequency(double frequency) {
+        xDistortModule.setFrequency(frequency);
+        yDistortModule.setFrequency(frequency);
+        zDistortModule.setFrequency(frequency);
+    }
+
+    public void setRoughness(int roughness) {
+        xDistortModule.setOctaveCount(roughness);
+        yDistortModule.setOctaveCount(roughness);
+        zDistortModule.setOctaveCount(roughness);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 1;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        if (sourceModule[0] == null) {
+            throw new NoModuleException();
+        }
+
+        // Get the values from the three noise::module::Perlin noise modules and
+        // add each value to each coordinate of the input value.  There are also
+        // some offsets added to the coordinates of the input values.  This prevents
+        // the distortion modules from returning zero if the (x, y, z) coordinates,
+        // when multiplied by the frequency, are near an integer boundary.  This is
+        // due to a property of gradient coherent noise, which returns zero at
+        // integer boundaries.
+        double x0, y0, z0;
+        double x1, y1, z1;
+        double x2, y2, z2;
+        x0 = x + (12414.0 / 65536.0);
+        y0 = y + (65124.0 / 65536.0);
+        z0 = z + (31337.0 / 65536.0);
+        x1 = x + (26519.0 / 65536.0);
+        y1 = y + (18128.0 / 65536.0);
+        z1 = z + (60493.0 / 65536.0);
+        x2 = x + (53820.0 / 65536.0);
+        y2 = y + (11213.0 / 65536.0);
+        z2 = z + (44845.0 / 65536.0);
+        double xDistort = x + (xDistortModule.getValue(x0, y0, z0) * power);
+        double yDistort = y + (yDistortModule.getValue(x1, y1, z1) * power);
+        double zDistort = z + (zDistortModule.getValue(x2, y2, z2) * power);
+
+        // Retrieve the output value at the offset input value instead of the
+        // original input value.
+        return sourceModule[0].getValue(xDistort, yDistort, zDistort);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Billow.java b/src/main/java/net/yatopia/server/module/source/Billow.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbfec47282902bc62a9be52da63a2d01e3e73eff
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Billow.java
@@ -0,0 +1,152 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.Noise;
+import org.spongepowered.noise.NoiseQuality;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+public class Billow extends Module {
+    public static final double DEFAULT_BILLOW_FREQUENCY = 1.0;
+    public static final double DEFAULT_BILLOW_LACUNARITY = 2.0;
+    public static final int DEFAULT_BILLOW_OCTAVE_COUNT = 6;
+    public static final double DEFAULT_BILLOW_PERSISTENCE = 0.5;
+    public static final NoiseQuality DEFAULT_BILLOW_QUALITY = NoiseQuality.STANDARD;
+    public static final int DEFAULT_BILLOW_SEED = 0;
+    public static final int BILLOW_MAX_OCTAVE = 30;
+    private double frequency = DEFAULT_BILLOW_FREQUENCY;
+    private double lacunarity = DEFAULT_BILLOW_LACUNARITY;
+    private NoiseQuality quality = DEFAULT_BILLOW_QUALITY;
+    private double persistence = DEFAULT_BILLOW_PERSISTENCE;
+    private int seed = DEFAULT_BILLOW_SEED;
+    private int octaveCount = DEFAULT_BILLOW_OCTAVE_COUNT;
+
+    public Billow() {
+        super(0);
+    }
+
+    public int getOctaveCount() {
+        return octaveCount;
+    }
+
+    public void setOctaveCount(int octaveCount) {
+        if (octaveCount < 1 || octaveCount > BILLOW_MAX_OCTAVE) {
+            throw new IllegalArgumentException("octaveCount must be between 1 and BILLOW_MAX_OCTAVE: " + BILLOW_MAX_OCTAVE);
+        }
+        this.octaveCount = octaveCount;
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    public double getLacunarity() {
+        return lacunarity;
+    }
+
+    public void setLacunarity(double lacunarity) {
+        this.lacunarity = lacunarity;
+    }
+
+    public NoiseQuality getQuality() {
+        return quality;
+    }
+
+    public void setQuality(NoiseQuality quality) {
+        this.quality = quality;
+    }
+
+    public double getPersistence() {
+        return persistence;
+    }
+
+    public void setPersistence(double persistence) {
+        this.persistence = persistence;
+    }
+
+    public int getSeed() {
+        return seed;
+    }
+
+    public void setSeed(int seed) {
+        this.seed = seed;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double z1 = z;
+        double y1 = y;
+        double x1 = x;
+        double value = 0.0;
+        double signal;
+        double curPersistence = 1.0;
+        double nx, ny, nz;
+        int seed;
+
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        for (int curOctave = 0; curOctave < octaveCount; curOctave++) {
+
+            // Make sure that these floating-point values have the same range as a 32-
+            // bit integer so that we can pass them to the coherent-noise functions.
+            nx = Utils.makeInt32Range(x1);
+            ny = Utils.makeInt32Range(y1);
+            nz = Utils.makeInt32Range(z1);
+
+            // Get the coherent-noise value from the input value and add it to the
+            // final result.
+            seed = (this.seed + curOctave);
+            signal = Noise.gradientCoherentNoise3D(nx, ny, nz, seed, quality) * 2 - 1;
+            signal = Math.abs(signal);
+            value += signal * curPersistence;
+
+            // Prepare the next octave.
+            x1 *= lacunarity;
+            y1 *= lacunarity;
+            z1 *= lacunarity;
+            curPersistence *= persistence;
+        }
+        value += 0.25;
+
+        return value;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Checkerboard.java b/src/main/java/net/yatopia/server/module/source/Checkerboard.java
new file mode 100644
index 0000000000000000000000000000000000000000..e1fc8128bc13502675b053268deaf40dff03e4ec
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Checkerboard.java
@@ -0,0 +1,53 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+public class Checkerboard extends Module {
+    public Checkerboard() {
+        super(0);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        int ix = Utils.floor(Utils.makeInt32Range(x));
+        int iy = Utils.floor(Utils.makeInt32Range(y));
+        int iz = Utils.floor(Utils.makeInt32Range(z));
+        return ((ix & 1 ^ iy & 1 ^ iz & 1) != 0) ? 0 : 1.0;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Const.java b/src/main/java/net/yatopia/server/module/source/Const.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff3975a5f542a91389449aa1f7f3e200c5f6481c
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Const.java
@@ -0,0 +1,59 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.module.Module;
+
+public class Const extends Module {
+    public static final double DEFAULT_VALUE = 0;
+    private double value = DEFAULT_VALUE;
+
+    public Const() {
+        super(0);
+    }
+
+    public double getValue() {
+        return value;
+    }
+
+    public void setValue(double value) {
+        this.value = value;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        return value;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Cylinders.java b/src/main/java/net/yatopia/server/module/source/Cylinders.java
new file mode 100644
index 0000000000000000000000000000000000000000..f324a883fc2e6e4aedb033d0f498d62ee2dfa077
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Cylinders.java
@@ -0,0 +1,69 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+public class Cylinders extends Module {
+    public static final double DEFAULT_CYLINDERS_FREQUENCY = 1.0;
+    private double frequency = DEFAULT_CYLINDERS_FREQUENCY;
+
+    public Cylinders() {
+        super(0);
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double z1 = z;
+        double x1 = x;
+        x1 *= frequency;
+        z1 *= frequency;
+
+        double distFromCenter = Math.sqrt(x1 * x1 + z1 * z1);
+        double distFromSmallerSphere = distFromCenter - Utils.floor(distFromCenter);
+        double distFromLargerSphere = 1.0 - distFromSmallerSphere;
+        double nearestDist = Math.min(distFromSmallerSphere, distFromLargerSphere);
+        return 1.0 - (nearestDist * 2.0); // Puts it in the 0 to 1 range.
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Perlin.java b/src/main/java/net/yatopia/server/module/source/Perlin.java
new file mode 100644
index 0000000000000000000000000000000000000000..732d34bd845d51c5249a2c0c68cc62599d0edf6c
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Perlin.java
@@ -0,0 +1,177 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.Noise;
+import org.spongepowered.noise.NoiseQuality;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+public class Perlin extends Module {
+    // Default frequency for the noise::module::Perlin noise module.
+    public static final double DEFAULT_PERLIN_FREQUENCY = 1.0;
+    // Default lacunarity for the noise::module::Perlin noise module.
+    public static final double DEFAULT_PERLIN_LACUNARITY = 2.0;
+    // Default number of octaves for the noise::module::Perlin noise module.
+    public static final int DEFAULT_PERLIN_OCTAVE_COUNT = 6;
+    // Default persistence value for the noise::module::Perlin noise module.
+    public static final double DEFAULT_PERLIN_PERSISTENCE = 0.5;
+    // Default noise quality for the noise::module::Perlin noise module.
+    public static final NoiseQuality DEFAULT_PERLIN_QUALITY = NoiseQuality.STANDARD;
+    // Default noise seed for the noise::module::Perlin noise module.
+    public static final int DEFAULT_PERLIN_SEED = 0;
+    // Maximum number of octaves for the noise::module::Perlin noise module.
+    public static final int PERLIN_MAX_OCTAVE = 30;
+    // Frequency of the first octave.
+    private double frequency = DEFAULT_PERLIN_FREQUENCY;
+    // Frequency multiplier between successive octaves.
+    private double lacunarity = DEFAULT_PERLIN_LACUNARITY;
+    // Quality of the Perlin noise.
+    private NoiseQuality noiseQuality = DEFAULT_PERLIN_QUALITY;
+    // Total number of octaves that generate the Perlin noise.
+    private int octaveCount = DEFAULT_PERLIN_OCTAVE_COUNT;
+    // Persistence of the Perlin noise.
+    private double persistence = DEFAULT_PERLIN_PERSISTENCE;
+    // Seed value used by the Perlin-noise function.
+    private int seed = DEFAULT_PERLIN_SEED;
+
+    public Perlin() {
+        super(0);
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    public double getLacunarity() {
+        return lacunarity;
+    }
+
+    public void setLacunarity(double lacunarity) {
+        this.lacunarity = lacunarity;
+    }
+
+    public NoiseQuality getNoiseQuality() {
+        return noiseQuality;
+    }
+
+    public void setNoiseQuality(NoiseQuality noiseQuality) {
+        this.noiseQuality = noiseQuality;
+    }
+
+    public int getOctaveCount() {
+        return octaveCount;
+    }
+
+    public void setOctaveCount(int octaveCount) {
+        if (octaveCount < 1 || octaveCount > PERLIN_MAX_OCTAVE) {
+            throw new IllegalArgumentException("octaveCount must be between 1 and MAX OCTAVE: " + PERLIN_MAX_OCTAVE);
+        }
+
+        this.octaveCount = octaveCount;
+    }
+
+    public double getPersistence() {
+        return persistence;
+    }
+
+    public void setPersistence(double persistence) {
+        this.persistence = persistence;
+    }
+
+    public int getSeed() {
+        return seed;
+    }
+
+    public void setSeed(int seed) {
+        this.seed = seed;
+    }
+    
+    /**
+     * Returns the maximum value the perlin module can output in its current configuration
+     * @return The maximum possible value for {@link Perlin#getValue(double, double, double)} to return
+     */
+    public double getMaxValue() {
+    	/*
+    	 * Each successive octave adds persistence ^ current_octaves to max possible output.
+    	 * So (p = persistence, o = octave): Max(perlin) = p + p*p + p*p*p + ... + p^(o-1).
+    	 * Using geometric series formula we can narrow it down to this:
+    	 */
+    	return (Math.pow(getPersistence(), getOctaveCount()) - 1) / (getPersistence() - 1);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double x1 = x;
+        double y1 = y;
+        double z1 = z;
+        double value = 0.0;
+        double signal;
+        double curPersistence = 1.0;
+        double nx, ny, nz;
+        int seed;
+
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        for (int curOctave = 0; curOctave < octaveCount; curOctave++) {
+
+            // Make sure that these floating-point values have the same range as a 32-
+            // bit integer so that we can pass them to the coherent-noise functions.
+            nx = Utils.makeInt32Range(x1);
+            ny = Utils.makeInt32Range(y1);
+            nz = Utils.makeInt32Range(z1);
+
+            // Get the coherent-noise value from the input value and add it to the
+            // final result.
+            seed = (this.seed + curOctave);
+            signal = Noise.gradientCoherentNoise3D(nx, ny, nz, seed, noiseQuality);
+            value += signal * curPersistence;
+
+            // Prepare the next octave.
+            x1 *= lacunarity;
+            y1 *= lacunarity;
+            z1 *= lacunarity;
+            curPersistence *= persistence;
+        }
+
+        return value;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/RidgedMulti.java b/src/main/java/net/yatopia/server/module/source/RidgedMulti.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c1673b0013e14a5829931256e3f2b9e936d70a4
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/RidgedMulti.java
@@ -0,0 +1,201 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+
+import net.yatopia.server.NoiseQuality;
+import net.yatopia.server.module.*;
+
+public class RidgedMulti extends Module {
+    // Default frequency for the noise::module::RidgedMulti noise module.
+    public static final double DEFAULT_RIDGED_FREQUENCY = 1.0;
+    // Default lacunarity for the noise::module::RidgedMulti noise module.
+    public static final double DEFAULT_RIDGED_LACUNARITY = 2.0;
+    // Default number of octaves for the noise::module::RidgedMulti noise module.
+    public static final int DEFAULT_RIDGED_OCTAVE_COUNT = 6;
+    // Default noise quality for the noise::module::RidgedMulti noise module.
+    public static final NoiseQuality DEFAULT_RIDGED_QUALITY = NoiseQuality.STANDARD;
+    // Default noise seed for the noise::module::RidgedMulti noise module.
+    public static final int DEFAULT_RIDGED_SEED = 0;
+    // Maximum number of octaves for the noise::module::RidgedMulti noise module.
+    public static final int RIDGED_MAX_OCTAVE = 30;
+    private double frequency = DEFAULT_RIDGED_FREQUENCY;
+    // Frequency multiplier between successive octaves.
+    private double lacunarity = DEFAULT_RIDGED_LACUNARITY;
+    // Quality of the ridged-multifractal noise.
+    private NoiseQuality noiseQuality = DEFAULT_RIDGED_QUALITY;
+    // Total number of octaves that generate the ridged-multifractal noise.
+    private int octaveCount = DEFAULT_RIDGED_OCTAVE_COUNT;
+    // Contains the spectral weights for each octave.
+    private double[] spectralWeights;
+    // Seed value used by the ridged-multfractal-noise function.
+    private int seed = DEFAULT_RIDGED_SEED;
+
+    public RidgedMulti() {
+        super(0);
+        calcSpectralWeights();
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    public double getLacunarity() {
+        return lacunarity;
+    }
+
+    public void setLacunarity(double lacunarity) {
+        this.lacunarity = lacunarity;
+    }
+
+    public NoiseQuality getNoiseQuality() {
+        return noiseQuality;
+    }
+
+    public void setNoiseQuality(NoiseQuality noiseQuality) {
+        this.noiseQuality = noiseQuality;
+    }
+
+    public int getOctaveCount() {
+        return octaveCount;
+    }
+
+    public void setOctaveCount(int octaveCount) {
+        this.octaveCount = Math.min(octaveCount, RIDGED_MAX_OCTAVE);
+    }
+
+    public int getSeed() {
+        return seed;
+    }
+
+    public void setSeed(int seed) {
+        this.seed = seed;
+    }
+
+    private void calcSpectralWeights() {
+        // This exponent parameter should be user-defined; it may be exposed in a
+        // future version of libnoise.
+        double h = 1.0;
+
+        double frequency = 1.0;
+        spectralWeights = new double[RIDGED_MAX_OCTAVE];
+        for (int i = 0; i < RIDGED_MAX_OCTAVE; i++) {
+            // Compute weight for each frequency.
+            spectralWeights[i] = Math.pow(frequency, -h);
+            frequency *= lacunarity;
+        }
+    }
+
+    /**
+     * Returns the maximum value the RidgedMulti module can output in its current configuration
+     * @return The maximum possible value for {@link RidgedMulti#getValue(double, double, double)} to return
+     */
+    public double getMaxValue() {
+    	/*
+    	 * Each successive octave adds (1/lacunarity) ^ current_octaves to max possible output.
+    	 * So (r = lacunarity, o = octave): Max(ridged) = 1 + 1/r + 1/(r*r) + 1/(r*r*r) + ... + (1/r^(o-1))
+    	 * See https://www.wolframalpha.com/input/?i=sum+from+k%3D0+to+n-1+of+1%2Fx%5Ek
+    	 */
+        return (getLacunarity() - Math.pow(getLacunarity(), 1 - getOctaveCount())) / (getLacunarity() - 1) / 1.6;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double x1 = x;
+        double y1 = y;
+        double z1 = z;
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        double signal;
+        double value = 0.0;
+        double weight = 1.0;
+
+        // These parameters should be user-defined; they may be exposed in a
+        // future version of libnoise.
+        double offset = 1.0;
+        double gain = 2.0;
+
+        for (int curOctave = 0; curOctave < octaveCount; curOctave++) {
+
+            // Make sure that these floating-point values have the same range as a 32-
+            // bit integer so that we can pass them to the coherent-noise functions.
+            double nx, ny, nz;
+            nx = Utils.makeInt32Range(x1);
+            ny = Utils.makeInt32Range(y1);
+            nz = Utils.makeInt32Range(z1);
+
+            // Get the coherent-noise value.
+            int seed = (this.seed + curOctave) & 0x7fffffff;
+            signal = Noise.gradientCoherentNoise3D(nx, ny, nz, seed, noiseQuality) * 2 - 1;
+
+            // Make the ridges.
+            signal = Math.abs(signal);
+            signal = offset - signal;
+
+            // Square the signal to increase the sharpness of the ridges.
+            signal *= signal;
+
+            // The weighting from the previous octave is applied to the signal.
+            // Larger values have higher weights, producing sharp points along the
+            // ridges.
+            signal *= weight;
+
+            // Weight successive contributions by the previous signal.
+            weight = signal * gain;
+            if (weight > 1.0) {
+                weight = 1.0;
+            }
+            if (weight < 0.0) {
+                weight = 0.0;
+            }
+
+            // Add the signal to the output value.
+            value += (signal * spectralWeights[curOctave]);
+
+            // Go to the next octave.
+            x1 *= lacunarity;
+            y1 *= lacunarity;
+            z1 *= lacunarity;
+        }
+
+        return value / 1.6;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/RidgedMultiSimplex.java b/src/main/java/net/yatopia/server/module/source/RidgedMultiSimplex.java
new file mode 100644
index 0000000000000000000000000000000000000000..7fb4822e39fcd40efbafa1964d3a371ad0786a90
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/RidgedMultiSimplex.java
@@ -0,0 +1,217 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+import net.yatopia.server.*;
+import net.yatopia.server.NoiseQualitySimplex;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * Generates ridged Simplex-style noise. The base Simplex uses a different formula but produces a similar appearance to classic Simplex.
+ * Default lattice orientation is XZ_BEFORE_Y. See {@link org.spongepowered.noise for recommended usage.
+ */
+public class RidgedMultiSimplex extends Module {
+    // Default frequency for the noise::module::RidgedMultiSimplex noise module.
+    public static final double DEFAULT_RIDGED_FREQUENCY = 1.0;
+    // Default lacunarity for the noise::module::RidgedMultiSimplex noise module.
+    public static final double DEFAULT_RIDGED_LACUNARITY = 2.0;
+    // Default number of octaves for the noise::module::RidgedMultiSimplex noise module.
+    public static final int DEFAULT_RIDGED_OCTAVE_COUNT = 6;
+    // Default lattice orientation for the noise::module::Simplex noise module.
+    public static final LatticeOrientation DEFAULT_SIMPLEX_ORIENTATION = LatticeOrientation.XZ_BEFORE_Y;
+    // Default noise quality for the noise::module::RidgedMultiSimplex noise module.
+    public static final NoiseQualitySimplex DEFAULT_RIDGED_QUALITY = NoiseQualitySimplex.SMOOTH;
+    // Default noise seed for the noise::module::RidgedMultiSimplex noise module.
+    public static final int DEFAULT_RIDGED_SEED = 0;
+    // Maximum number of octaves for the noise::module::RidgedMultiSimplex noise module.
+    public static final int RIDGED_MAX_OCTAVE = 30;
+    private double frequency = DEFAULT_RIDGED_FREQUENCY;
+    // Frequency multiplier between successive octaves.
+    private double lacunarity = DEFAULT_RIDGED_LACUNARITY;
+    // Lattice Orientation of the Simplex-style noise.
+    private LatticeOrientation latticeOrientation = DEFAULT_SIMPLEX_ORIENTATION;
+    // Quality of the ridged-multifractal noise.
+    private NoiseQualitySimplex noiseQuality = DEFAULT_RIDGED_QUALITY;
+    // Total number of octaves that generate the ridged-multifractal noise.
+    private int octaveCount = DEFAULT_RIDGED_OCTAVE_COUNT;
+    // Contains the spectral weights for each octave.
+    private double[] spectralWeights;
+    // Seed value used by the ridged-multfractal-noise function.
+    private int seed = DEFAULT_RIDGED_SEED;
+
+    public RidgedMultiSimplex() {
+        super(0);
+        calcSpectralWeights();
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    public double getLacunarity() {
+        return lacunarity;
+    }
+
+    public void setLacunarity(double lacunarity) {
+        this.lacunarity = lacunarity;
+    }
+
+    public LatticeOrientation getLatticeOrientation() {
+        return latticeOrientation;
+    }
+
+    public void setLatticeOrientation(LatticeOrientation latticeOrientation) {
+        this.latticeOrientation = latticeOrientation;
+    }
+
+    public NoiseQualitySimplex getNoiseQuality() {
+        return noiseQuality;
+    }
+
+    public void setNoiseQuality(NoiseQualitySimplex noiseQuality) {
+        this.noiseQuality = noiseQuality;
+    }
+
+    public int getOctaveCount() {
+        return octaveCount;
+    }
+
+    public void setOctaveCount(int octaveCount) {
+        this.octaveCount = Math.min(octaveCount, RIDGED_MAX_OCTAVE);
+    }
+
+    public int getSeed() {
+        return seed;
+    }
+
+    public void setSeed(int seed) {
+        this.seed = seed;
+    }
+
+    private void calcSpectralWeights() {
+        // This exponent parameter should be user-defined; it may be exposed in a
+        // future version of libnoise.
+        double h = 1.0;
+
+        double frequency = 1.0;
+        spectralWeights = new double[RIDGED_MAX_OCTAVE];
+        for (int i = 0; i < RIDGED_MAX_OCTAVE; i++) {
+            // Compute weight for each frequency.
+            spectralWeights[i] = Math.pow(frequency, -h);
+            frequency *= lacunarity;
+        }
+    }
+
+    /**
+     * Returns the maximum value the RidgedMultiSimplex module can output in its current configuration
+     * @return The maximum possible value for {@link RidgedMultiSimplex#getValue(double, double, double)} to return
+     */
+    public double getMaxValue() {
+    	/*
+    	 * Each successive octave adds (1/lacunarity) ^ current_octaves to max possible output.
+    	 * So (r = lacunarity, o = octave): Max(ridged) = 1 + 1/r + 1/(r*r) + 1/(r*r*r) + ... + (1/r^(o-1))
+    	 * See https://www.wolframalpha.com/input/?i=sum+from+k%3D0+to+n-1+of+1%2Fx%5Ek
+    	 */
+        return (getLacunarity() - Math.pow(getLacunarity(), 1 - getOctaveCount())) / (getLacunarity() - 1) / 1.6;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double x1 = x;
+        double y1 = y;
+        double z1 = z;
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        double signal;
+        double value = 0.0;
+        double weight = 1.0;
+
+        // These parameters should be user-defined; they may be exposed in a
+        // future version of libnoise.
+        double offset = 1.0;
+        double gain = 2.0;
+
+        for (int curOctave = 0; curOctave < octaveCount; curOctave++) {
+
+            // Make sure that these floating-point values have the same range as a 32-
+            // bit integer so that we can pass them to the coherent-noise functions.
+            double nx, ny, nz;
+            nx = Utils.makeInt32Range(x1);
+            ny = Utils.makeInt32Range(y1);
+            nz = Utils.makeInt32Range(z1);
+
+            // Get the coherent-noise value.
+            int seed = (this.seed + curOctave) & 0x7fffffff;
+            signal = Noise.simplexStyleGradientCoherentNoise3D(nx, ny, nz, seed, latticeOrientation, noiseQuality) * 2 - 1;
+
+            // Make the ridges.
+            signal = Math.abs(signal);
+            signal = offset - signal;
+
+            // Square the signal to increase the sharpness of the ridges.
+            signal *= signal;
+
+            // The weighting from the previous octave is applied to the signal.
+            // Larger values have higher weights, producing sharp points along the
+            // ridges.
+            signal *= weight;
+
+            // Weight successive contributions by the previous signal.
+            weight = signal * gain;
+            if (weight > 1.0) {
+                weight = 1.0;
+            }
+            if (weight < 0.0) {
+                weight = 0.0;
+            }
+
+            // Add the signal to the output value.
+            value += (signal * spectralWeights[curOctave]);
+
+            // Go to the next octave.
+            x1 *= lacunarity;
+            y1 *= lacunarity;
+            z1 *= lacunarity;
+        }
+
+        return value / 1.6;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Simplex.java b/src/main/java/net/yatopia/server/module/source/Simplex.java
new file mode 100644
index 0000000000000000000000000000000000000000..383d400549d127628db793565d34bbee5b9b1130
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Simplex.java
@@ -0,0 +1,193 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+import net.yatopia.server.*;
+
+import org.spongepowered.noise.Noise.*;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+/**
+ * Generates summed octave Simplex-style noise. The base Simplex uses a different formula but produces a similar appearance to classic Simplex.
+ * Default lattice orientation is XZ_BEFORE_Y. See {@link} for recommended usage.
+ */
+public class Simplex extends Module {
+    // Default frequency for the noise::module::Simplex noise module.
+    public static final double DEFAULT_SIMPLEX_FREQUENCY = 1.0;
+    // Default lacunarity for the noise::module::Simplex noise module.
+    public static final double DEFAULT_SIMPLEX_LACUNARITY = 2.0;
+    // Default number of octaves for the noise::module::Simplex noise module.
+    public static final int DEFAULT_SIMPLEX_OCTAVE_COUNT = 6;
+    // Default persistence value for the noise::module::Simplex noise module.
+    public static final double DEFAULT_SIMPLEX_PERSISTENCE = 0.5;
+    // Default lattice orientation for the noise::module::Simplex noise module.
+    public static final LatticeOrientation DEFAULT_SIMPLEX_ORIENTATION = LatticeOrientation.XZ_BEFORE_Y;
+    // Default noise quality for the noise::module::Simplex noise module.
+    public static final NoiseQualitySimplex DEFAULT_SIMPLEX_QUALITY = NoiseQualitySimplex.STANDARD;
+    // Default noise seed for the noise::module::Simplex noise module.
+    public static final int DEFAULT_SIMPLEX_SEED = 0;
+    // Maximum number of octaves for the noise::module::Simplex noise module.
+    public static final int SIMPLEX_MAX_OCTAVE = 30;
+    // Frequency of the first octave.
+    private double frequency = DEFAULT_SIMPLEX_FREQUENCY;
+    // Frequency multiplier between successive octaves.
+    private double lacunarity = DEFAULT_SIMPLEX_LACUNARITY;
+    // Lattice Orientation of the Simplex-style noise.
+    private LatticeOrientation latticeOrientation = DEFAULT_SIMPLEX_ORIENTATION;
+    // Quality of the Simplex-style noise.
+    private NoiseQualitySimplex noiseQuality = DEFAULT_SIMPLEX_QUALITY;
+    // Total number of octaves that generate the Simplex-style noise.
+    private int octaveCount = DEFAULT_SIMPLEX_OCTAVE_COUNT;
+    // Persistence of the Simplex-style noise.
+    private double persistence = DEFAULT_SIMPLEX_PERSISTENCE;
+    // Seed value used by the Simplex-style noise function.
+    private int seed = DEFAULT_SIMPLEX_SEED;
+
+    public Simplex() {
+        super(0);
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    public double getLacunarity() {
+        return lacunarity;
+    }
+
+    public void setLacunarity(double lacunarity) {
+        this.lacunarity = lacunarity;
+    }
+
+    public LatticeOrientation getLatticeOrientation() {
+        return latticeOrientation;
+    }
+
+    public void setLatticeOrientation(LatticeOrientation latticeOrientation) {
+        this.latticeOrientation = latticeOrientation;
+    }
+
+    public NoiseQualitySimplex getNoiseQuality() {
+        return noiseQuality;
+    }
+
+    public void setNoiseQuality(NoiseQualitySimplex noiseQuality) {
+        this.noiseQuality = noiseQuality;
+    }
+
+    public int getOctaveCount() {
+        return octaveCount;
+    }
+
+    public void setOctaveCount(int octaveCount) {
+        if (octaveCount < 1 || octaveCount > SIMPLEX_MAX_OCTAVE) {
+            throw new IllegalArgumentException("octaveCount must be between 1 and MAX OCTAVE: " + SIMPLEX_MAX_OCTAVE);
+        }
+
+        this.octaveCount = octaveCount;
+    }
+
+    public double getPersistence() {
+        return persistence;
+    }
+
+    public void setPersistence(double persistence) {
+        this.persistence = persistence;
+    }
+
+    public int getSeed() {
+        return seed;
+    }
+
+    public void setSeed(int seed) {
+        this.seed = seed;
+    }
+    
+    /**
+     * Returns the maximum value the simplex module can output in its current configuration
+     * @return The maximum possible value for {@link Simplex#getValue(double, double, double)} to return
+     */
+    public double getMaxValue() {
+    	/*
+    	 * Each successive octave adds persistence ^ current_octaves to max possible output.
+    	 * So (p = persistence, o = octave): Max(simplex) = p + p*p + p*p*p + ... + p^(o-1).
+    	 * Using geometric series formula we can narrow it down to this:
+    	 */
+    	return (Math.pow(getPersistence(), getOctaveCount()) - 1) / (getPersistence() - 1);
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double x1 = x;
+        double y1 = y;
+        double z1 = z;
+        double value = 0.0;
+        double signal;
+        double curPersistence = 1.0;
+        double nx, ny, nz;
+        int seed;
+
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        for (int curOctave = 0; curOctave < octaveCount; curOctave++) {
+
+            // Make sure that these floating-point values have the same range as a 32-
+            // bit integer so that we can pass them to the coherent-noise functions.
+            nx = Utils.makeInt32Range(x1);
+            ny = Utils.makeInt32Range(y1);
+            nz = Utils.makeInt32Range(z1);
+
+            // Get the coherent-noise value from the input value and add it to the
+            // final result.
+            seed = (this.seed + curOctave);
+            signal = Noise.simplexStyleGradientCoherentNoise3D(nx, ny, nz, seed, latticeOrientation, noiseQuality);
+            value += signal * curPersistence;
+
+            // Prepare the next octave.
+            x1 *= lacunarity;
+            y1 *= lacunarity;
+            z1 *= lacunarity;
+            curPersistence *= persistence;
+        }
+
+        return value;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Spheres.java b/src/main/java/net/yatopia/server/module/source/Spheres.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a440edc5d253ba233ca36b91752f8504af31999
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Spheres.java
@@ -0,0 +1,73 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+public class Spheres extends Module {
+    // Default frequency value for the noise::module::Spheres noise module.
+    public static final double DEFAULT_SPHERES_FREQUENCY = 1.0;
+    // Frequency of the concentric spheres.
+    private double frequency = DEFAULT_SPHERES_FREQUENCY;
+
+    public Spheres() {
+        super(0);
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double x1 = x;
+        double y1 = y;
+        double z1 = z;
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        double distFromCenter = Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1);
+        double distFromSmallerSphere = distFromCenter - Utils.floor(distFromCenter);
+        double distFromLargerSphere = 1.0 - distFromSmallerSphere;
+        double nearestDist = Math.min(distFromSmallerSphere, distFromLargerSphere);
+        return 1.0 - (nearestDist * 2.0); // Puts it in the 0 to 1 range.
+    }
+}
diff --git a/src/main/java/net/yatopia/server/module/source/Voronoi.java b/src/main/java/net/yatopia/server/module/source/Voronoi.java
new file mode 100644
index 0000000000000000000000000000000000000000..6922ae7f1da31be566281fb885dff64c007fe23a
--- /dev/null
+++ b/src/main/java/net/yatopia/server/module/source/Voronoi.java
@@ -0,0 +1,163 @@
+/*
+ * This file is part of Noise, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Flow Powered <https://github.com/flow>
+ * Copyright (c) SpongePowered <https://github.com/SpongePowered>
+ * Copyright (c) contributors
+ *
+ * Original libnoise C++ library by Jason Bevins <http://libnoise.sourceforge.net>
+ * jlibnoise Java port by Garrett Fleenor <https://github.com/RoyAwesome/jlibnoise>
+ * Noise is re-licensed with permission from jlibnoise author.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.yatopia.server.module.source;
+
+import org.spongepowered.noise.Noise;
+import org.spongepowered.noise.Utils;
+import org.spongepowered.noise.module.Module;
+
+public class Voronoi extends Module {
+    private static final double SQRT_3 = 1.7320508075688772935;
+    // Default displacement to apply to each cell for the
+    // noise::module::Voronoi noise module.
+    public static final double DEFAULT_VORONOI_DISPLACEMENT = 1.0;
+    // Default frequency of the seed points for the noise::module::Voronoi
+    // noise module.
+    public static final double DEFAULT_VORONOI_FREQUENCY = 1.0;
+    // Default seed of the noise function for the noise::module::Voronoi
+    // noise module.
+    public static final int DEFAULT_VORONOI_SEED = 0;
+    // Scale of the random displacement to apply to each Voronoi cell.
+    private double displacement = DEFAULT_VORONOI_DISPLACEMENT;
+    // Determines if the distance from the nearest seed point is applied to
+    // the output value.
+    private boolean enableDistance = false;
+    // Frequency of the seed points.
+    private double frequency = DEFAULT_VORONOI_FREQUENCY;
+    // Seed value used by the coherent-noise function to determine the
+    // positions of the seed points.
+    private int seed = DEFAULT_VORONOI_SEED;
+
+    public Voronoi() {
+        super(0);
+    }
+
+    public double getDisplacement() {
+        return displacement;
+    }
+
+    public void setDisplacement(double displacement) {
+        this.displacement = displacement;
+    }
+
+    public boolean isEnableDistance() {
+        return enableDistance;
+    }
+
+    public void setEnableDistance(boolean enableDistance) {
+        this.enableDistance = enableDistance;
+    }
+
+    public double getFrequency() {
+        return frequency;
+    }
+
+    public void setFrequency(double frequency) {
+        this.frequency = frequency;
+    }
+
+    public int getSeed() {
+        return seed;
+    }
+
+    public void setSeed(int seed) {
+        this.seed = seed;
+    }
+
+    @Override
+    public int getSourceModuleCount() {
+        return 0;
+    }
+
+    @Override
+    public double getValue(double x, double y, double z) {
+        double x1 = x;
+        double y1 = y;
+        double z1 = z;
+        // This method could be more efficient by caching the seed values.  Fix
+        // later.
+
+        x1 *= frequency;
+        y1 *= frequency;
+        z1 *= frequency;
+
+        int xInt = (x1 > 0.0 ? (int) x1 : (int) x1 - 1);
+        int yInt = (y1 > 0.0 ? (int) y1 : (int) y1 - 1);
+        int zInt = (z1 > 0.0 ? (int) z1 : (int) z1 - 1);
+
+        double minDist = 2147483647.0;
+        double xCandidate = 0;
+        double yCandidate = 0;
+        double zCandidate = 0;
+
+        // Inside each unit cube, there is a seed point at a random position.  Go
+        // through each of the nearby cubes until we find a cube with a seed point
+        // that is closest to the specified position.
+        for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {
+            for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {
+                for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {
+
+                    // Calculate the position and distance to the seed point inside of
+                    // this unit cube.
+                    double xPos = xCur + Noise.valueNoise3D(xCur, yCur, zCur, seed);
+                    double yPos = yCur + Noise.valueNoise3D(xCur, yCur, zCur, seed + 1);
+                    double zPos = zCur + Noise.valueNoise3D(xCur, yCur, zCur, seed + 2);
+                    double xDist = xPos - x1;
+                    double yDist = yPos - y1;
+                    double zDist = zPos - z1;
+                    double dist = xDist * xDist + yDist * yDist + zDist * zDist;
+
+                    if (dist < minDist) {
+                        // This seed point is closer to any others found so far, so record
+                        // this seed point.
+                        minDist = dist;
+                        xCandidate = xPos;
+                        yCandidate = yPos;
+                        zCandidate = zPos;
+                    }
+                }
+            }
+        }
+
+        double value;
+        if (enableDistance) {
+            // Determine the distance to the nearest seed point.
+            double xDist = xCandidate - x1;
+            double yDist = yCandidate - y1;
+            double zDist = zCandidate - z1;
+            value = Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist) / SQRT_3;
+        } else {
+            value = 0.0;
+        }
+
+        // Return the calculated distance with the displacement value applied.
+        return value + (displacement * Noise.valueNoise3D(Utils.floor(xCandidate), Utils.floor(yCandidate), Utils.floor(zCandidate), seed));
+    }
+}
